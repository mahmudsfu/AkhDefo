{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Morenney Rock Glacier Radar Imagery Example"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Prepare Data for Bulk Download\n",
    "\n",
    "Akhdefo processes radar imagery that has been corrected for radiometric and terrain distortions. Its function, 'download_RTC,' enables the downloading of Synthetic Aperture Radar (SAR) products from ASF's HyP3 platform. Users can easily order RTC, AutoRIFT, and InSAR products with just a few lines of Python script.\n",
    "Firstly, users are advised to visit [ASF's website](https://search.asf.alaska.edu/#/?maxResults=250) to download metadata for their chosen time-series product granules. To assist users, example screenshots are provided below as a guide to navigate through the process.\n",
    "\n",
    "\n",
    "![Step 1](data/asf1.png)\n",
    "\n",
    "\n",
    "![Step 1](data/asf2.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Import AkhDefo Packages."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "#Functions for data preparations\n",
    "import akhdefo_functions\n",
    "from akhdefo_functions import download_RTC\n",
    "from akhdefo_functions import read_data_prep\n",
    "from akhdefo_functions import move_files_with_string\n",
    "from akhdefo_functions import Crop_to_AOI\n",
    "\n",
    "#Functions data processing\n",
    "from akhdefo_functions import scatter_area_mask\n",
    "from akhdefo_functions import Raster_Correction\n",
    "from akhdefo_functions import radar_flow_akhdefo\n",
    "\n",
    "#Functions for shapefile point data interpolation to raster geotif\n",
    "#Function Autovariogram use Kriging method it fits the data to different variogram models and automatically use the best fit variogram model (Computationally Heavy but you can process data in chunks)\n",
    "from akhdefo_functions import Auto_Variogram\n",
    "\n",
    "# interpoate_xyz uses the following interpolation methods (nearest, linear and cubic)\n",
    "from akhdefo_functions import interpolate_xyz\n",
    "\n",
    "#Functions for data Visualization and Analysis\n",
    "from akhdefo_functions import MeanProducts_plot_ts\n",
    "from akhdefo_functions import plot_stackNetwork\n",
    "from akhdefo_functions import akhdefo_viewer\n",
    "from akhdefo_functions import akhdefo_dashApp"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Download Data using EarthData ASF Account"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "''' \n",
    "\n",
    "First Run the below command and make sure {download=False} to see the granule paths and frames. \n",
    "\n",
    "Its highly recommended to use data frame same path for the entire time-series for more accurate results\n",
    " \n",
    "'''\n",
    "\n",
    "\n",
    "# download_RTC( prompt=True, asf_datapool_results_file= './data/morenny/radar/asf-datapool-results-2023-12-19_04-01-18.csv', \n",
    "#             save_dir= './data/morenny/radar/path129', job_name= './data/morenny/radar/RockGlacier_asc', \n",
    "#             dem_matching= False, \n",
    "#             include_dem= False, \n",
    "#             include_inc_map= True, \n",
    "#             include_rgb = False, \n",
    "#             include_scattering_area= True, \n",
    "#             scale = 'power', \n",
    "#             resolution = 20, \n",
    "#             speckle_filter= False,\n",
    "#             radiometry='gamma0',\n",
    "#             dem_name='copernicus', limit=None , download=False , path_number=129, RTC=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Extract downloaded zip files"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#This functions extracts data from all the granuples zip directory.\n",
    "read_data_prep(zip_dir='./data/morenny/radar/path129_rtc/',\n",
    "                                 image_dir='./data/morenny/radar/RS_dir_path129', \n",
    "                                 ext_image_file='VV.tif', udm_mask_dir='./data/morenny/radar/scatter_dir', ext_udm_mask_file='area.tif')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# This function will move all the data from each granules subdir to a single folder\n",
    "move_files_with_string(source_dir='./data/morenny/radar/RS_dir_path129', dest_dir='./data/morenny/radar/RS_path129', search_string='.tif')\n",
    "move_files_with_string(source_dir='./data/morenny/radar/scatter_dir', dest_dir='./data/morenny/radar/scatter_rs', search_string='area.tif')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "'''  \n",
    "Optional:\n",
    "\n",
    "Create an accumulated scatter area mask from a set of raster images based on a given threshold. \n",
    "the input dataset is taken from ASF RTC processing.\n",
    "The scattering area for each pixel in the RTC image in square meters. \n",
    "The values are calculated based on the effectively illuminated gamma-0 terrain surface using a digital elevation model,\n",
    "the local incidence angle map, and the layover-shadow map. see detailes \n",
    "at the following website https://hyp3-docs.asf.alaska.edu/guides/rtc_product_guide/#scattering-area-map\n",
    "The function processes each raster image in the input folder, crops it based on the provided AOI from the shapefile,\n",
    "normalizes the cropped raster, and then converts the normalized image to a binary mask based on the scatter_percentageArea_threshold. \n",
    "The binary masks from each raster are then accumulated to generate the final scatter area mask.\n",
    "\n",
    "'''\n",
    "\n",
    "input_folder = \"./data/morenny/radar/scatter_rs\"\n",
    "output_folder = \"./data/morenny/radar/scatter_masks_20\"\n",
    "plot_folder = \"./data/morenny/radar/scatter_mask_plots_20\"\n",
    "shapefile_path = \"./data/morenny/AOI.shp\"\n",
    "scatter_Area_threshold=5\n",
    "vegetation_mask_path=None\n",
    "\n",
    "\n",
    "#scatter_area_mask(input_folder, output_folder, plot_folder, shapefile_path, scatter_Area_threshold, vegetation_mask_path)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "''' \n",
    "Crop all raster to Area of interest bounding box\n",
    "\n",
    "\n",
    "'''\n",
    "Crop_to_AOI(Path_to_WorkingDir='./data/morenny/radar/RS_path129/', \n",
    "                              Path_to_AOI_shapefile='./data/morenny/AOI.shp', \n",
    "                              output_CroppedDir='./data/morenny/radar/RS_cropped_path129', file_ex='.tif')\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Preparing raster for radar flow and displacement calculation!\n",
    "\n",
    "By deafult RTC data comes in the below three formats. The below raster correction function converts the below RTC data formats to Unassigned 8 bit integer(\"uint8\").\n",
    "\n",
    "- Power Scale: SAR images in the power scale represent the square of the amplitude. Power is a measure of the energy of the radar signal returned from each point on the ground. It's more intuitive in terms of energy interpretation but less used for visual interpretation due to its non-linear nature.\n",
    "\n",
    "- Amplitude Scale: The amplitude scale is a direct representation of the radar signal's strength received from each point. It's more commonly used for visual interpretation since it's more linear than the power scale. Amplitude images are easier to interpret but can be sensitive to noise.\n",
    "\n",
    "- Decibel (dB) Scale: The decibel scale is a logarithmic scale used to express SAR data. It's derived from the amplitude or power scale and is used to compress the dynamic range of the SAR data. The dB scale is beneficial for enhancing certain features in the data, especially in areas with very high or very low backscatter.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "\n",
    "Raster_Correction(input_path=\"./data/morenny/radar/RS_cropped_path129\", output_path=\"./data/morenny/radar/RS_cropped_path129_filt\", limit=None,\n",
    "                                    lowpass_kernel_size=None, bilateral_win_size=7, bilateral_sigma_color=75,\n",
    "                                    bilateral_sigma_spatial=75,\n",
    "                                    clip_percentiles=[2, 98], radar=False, \n",
    "                                    scale='power', Vegetation_mask=None)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Applying radar flow and producing time-series deformation products."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "import akhdefo_functions\n",
    "akhdefo_functions.radar_flow_akhdefo(input_dir='./data/morenny/radar/RS_cropped_path129_filt', output_dir='./data/morenny/radar/geo_path129', AOI='./data/morenny/AOI.shp', zscore_threshold=2, \n",
    "                                       ssim_thresh=0.6, image_resolution='20m', interpolate='kriging', \n",
    "                                       show_figure=False, point_size=2, dem_path='./data/morenny/dem.tif', smoothing_kernel_size=None, \n",
    "                                       Vegetation_mask=None, VEL_scale='year', VEL_Mode='linear', good_match_option=0.75, \n",
    "                                       hillshade_option=True, shapefile_output=True, max_triplet_interval=300, pixel_size=20, num_chunks=1, overlap_percentage=0, pyr_scale=0.5, levels=15, \n",
    "                                       winsize=128, iterations=7, poly_n=7, poly_sigma=1.5,\n",
    "                                       flags=1, master_reference='single', \n",
    "                                       selection_Mode='pair', start_date=None, end_date=None, krig_method='universal', spatial_ref=True, use_detrend=False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Interpolate and Create raster Velocities"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import akhdefo_functions\n",
    "from akhdefo_functions import Auto_Variogram\n",
    "\n",
    "Auto_Variogram(data='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_N.shp', column_attribute='VEL'\n",
    "               , pixel_size=20, num_chunks=41, out_fileName='N', geo_folder='./data/morenny/radar/VEL_Folder', plot_folder='./data/morenny/radar/VEL_Folder'\n",
    "               , smoothing_kernel=3, latlon=False, aoi_shapefile='./data/morenny/AOI.shp' ,  krig_method='universal')\n",
    "\n",
    "\n",
    "Auto_Variogram(data='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_E.shp', column_attribute='VEL'\n",
    "               , pixel_size=20, num_chunks=4, out_fileName='E', geo_folder='./data/morenny/radar/VEL_Folder', plot_folder='./data/morenny/radar/VEL_Folder'\n",
    "               , smoothing_kernel=3, latlon=False, aoi_shapefile='./data/morenny/AOI.shp',  krig_method='universal')\n",
    "\n",
    "\n",
    "\n",
    "Auto_Variogram(data='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_2DVEL.shp', column_attribute='VEL'\n",
    "               , pixel_size=20, num_chunks=4, out_fileName='2DVEL', geo_folder='./data/morenny/radar/VEL_Folder', plot_folder='./data/morenny/radar/VEL_Folder'\n",
    "               , smoothing_kernel=3, latlon=False, aoi_shapefile='./data/morenny/AOI.shp',  krig_method='universal')\n",
    "\n",
    "\n",
    "\n",
    "Auto_Variogram(data='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_2DVEL.shp', column_attribute='aspect'\n",
    "               , pixel_size=20, num_chunks=4, out_fileName='aspect', geo_folder='./data/morenny/radar/VEL_Folder', plot_folder='./data/morenny/radar/VEL_Folder'\n",
    "               , smoothing_kernel=3, latlon=False, aoi_shapefile='./data/morenny/AOI.shp',  krig_method='universal')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Visualize Displacement Products"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import akhdefo_functions\n",
    "import cmocean.cm as cmo\n",
    "\n",
    "akhdefo_functions.akhdefo_viewer(path_to_dem_file='./data/morenny/basemap.tif', raster_file='./data/morenny/radar/VEL_Folder/2DVEL_universal.tif', output_folder='./data/morenny/radar/Figs_analysis/', title='2D Velocity with Vector Motion', \n",
    "                   pixel_resolution_meters=None, output_file_name=\"2DVEL_WithVectorMotion.png\", \n",
    "                   alpha=0.4, unit_conversion=None, no_data_mask=True, \n",
    "                   colormap='hot_r', min_value=None, max_value=None, \n",
    "                   normalize=True, colorbar_label='meter/year', show_figure=True, aspect_raster='./data/morenny/radar/VEL_Folder/aspect_universal.tif', cmap_aspect='hsv' , step=5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#Visualize Mean Velocity East-West\n",
    "# if set batch_plot=True it will plot static time series figure for each date acquisition \n",
    "import akhdefo_functions\n",
    "akhdefo_functions.MeanProducts_plot_ts(path_to_shapefile='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_E.shp', \n",
    "                                       dem_path='./data/morenny/dem.tif', out_folder='./data/morenny/radar/Figs_analysis/E', \n",
    "                                       color_field=\"VEL\", Set_fig_MinMax=True, \n",
    "                                       MinMaxRange=[-0.2, 0.2], opacity=0.7,\n",
    "                                       cmap='bwr', point_size=10, \n",
    "                                       cbar_label='East-West (m/year)', \n",
    "                                       batch_plot=False)\n",
    "\n",
    "#Visualize Mean Velocity North-South\n",
    "akhdefo_functions.MeanProducts_plot_ts(path_to_shapefile='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_N.shp', \n",
    "                                       dem_path='./data/morenny/dem.tif', out_folder='./data/morenny/radar/Figs_analysis/N', \n",
    "                                       color_field=\"VEL\", Set_fig_MinMax=False, \n",
    "                                       MinMaxRange=[0, 1.5], opacity=0.7,\n",
    "                                       cmap='bwr', point_size=10, \n",
    "                                       cbar_label='North-South (m/year)', \n",
    "                                       batch_plot=False)\n",
    "\n",
    "#Visualize Mean Velocity 2D Velocity \n",
    "akhdefo_functions.MeanProducts_plot_ts(path_to_shapefile='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_2DVEL.shp', \n",
    "                                       dem_path='./data/morenny/dem.tif', out_folder='./data/morenny/radar/Figs_analysis/2D', \n",
    "                                       color_field=\"VEL\", Set_fig_MinMax=False, \n",
    "                                       MinMaxRange=[-0.5, 0.5], opacity=0.7,\n",
    "                                       cmap='plasma', point_size=10, \n",
    "                                       cbar_label='2D-VEL (meter/year)', \n",
    "                                       batch_plot=False, plot_inverse_Vel=True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Interactive Time Series Analysis in a Dash Web App\n",
    "\n",
    "This plot is part of an interactive web application. Users have the ability to select groups of data points using either the box select or lasso tool, which are superimposed on a satellite image base map. The selected data will then be reflected in the time series chart. Additionally, users can customize the axis labels to suit their dataset; for example, if the dataset measures displacement or velocity in meters, the y-axis label can be adjusted accordingly from the default mm. Furthermore, users can download their analysis and the generated figures directly from the web application.\n",
    "\n",
    "![dash2d_radar output sample](./data/morenny/radar/dash2d1.png)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "![dash2d_radar output sample1](./data/morenny/radar/newplot111.png)\n",
    "\n",
    "![dash2d_radar output sample2](./data/morenny/radar/newplot12.png)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import akhdefo_functions\n",
    "\n",
    "akhdefo_functions.akhdefo_dashApp(\n",
    "Path_to_Shapefile='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_2DVEL.shp',\n",
    "                                  port=8057, BaseMap=True, basemap_type='image')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "akhdefo_dashApp(\n",
    "Path_to_Shapefile='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_N.shp',\n",
    "                                  port=8056, BaseMap=True, basemap_type='image')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "akhdefo_dashApp(\n",
    "Path_to_Shapefile='./data/morenny/radar/geo_path129/temp_shapefile_dir/updated_shapefiles/20150717_20230921_20230921_E.shp',\n",
    "                                  port=8055, BaseMap=True, basemap_type='image')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Plot Mean Land Surface Temperature for months July and August 2017 to 2021"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import akhdefo_functions\n",
    "from osgeo import gdal\n",
    "import tempfile\n",
    "import numpy as np \n",
    "import datetime\n",
    "import re\n",
    "import pandas as pd\n",
    "import ee\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import seaborn as sns  # For enhanced plot styling\n",
    "from scipy.stats import linregress\n",
    "import geopandas as gpd \n",
    "directory_path = './data/morenny/LST/'\n",
    "basemap_path = './data/morenny/basemap.tif'\n",
    "\n",
    "# Read the projection from the basemap\n",
    "basemap_ds = gdal.Open(basemap_path)\n",
    "basemap_proj = basemap_ds.GetProjection()\n",
    "\n",
    "# List all files in the specified path\n",
    "entries = os.listdir(directory_path)\n",
    "\n",
    "mean_values = []\n",
    "filenames = []\n",
    "\n",
    "dates=[]\n",
    "date_pattern = r'\\d{4}\\d{2}\\d{2}'  # Adjust this pattern based on your filename date format\n",
    "\n",
    "def extract_year_from_string(s):\n",
    "    # Regular expression pattern to find a four-digit year\n",
    "    pattern = r'\\d{4}'\n",
    "    match = re.search(pattern, s)\n",
    "\n",
    "    if match:\n",
    "        # Return the matched year\n",
    "        return match.group()\n",
    "    else:\n",
    "        return None\n",
    "\n",
    "# Test the function\n",
    "       \n",
    "for f in entries:\n",
    "    full_path = os.path.join(directory_path, f)\n",
    "    if full_path.endswith('.tif'):\n",
    "        file_name = os.path.basename(full_path)\n",
    "\n",
    "        # Create a temporary file for the reprojected raster\n",
    "        temp_outputname = os.path.join(tempfile.gettempdir(), f'reprojected_{file_name}')\n",
    "\n",
    "        # Reproject the raster to match the basemap's projection\n",
    "        gdal.Warp(destNameOrDestDS=temp_outputname,\n",
    "                  srcDSOrSrcDSTab=full_path,\n",
    "                  dstSRS=basemap_proj)\n",
    "        \n",
    "        ####################\n",
    "         # Open the reprojected raster and calculate its mean\n",
    "        ds = gdal.Open(temp_outputname)\n",
    "        band = ds.GetRasterBand(1)\n",
    "        data = band.ReadAsArray()\n",
    "        mean_value = np.nanmean(data)  # Exclude no-data values\n",
    "        filenames.append(file_name)\n",
    "        match = re.search(date_pattern, file_name)\n",
    "        year=extract_year_from_string(file_name)\n",
    "        mean_values.append(mean_value)\n",
    "        dates.append(year)\n",
    "        \n",
    "        #################\n",
    "        \n",
    "        # Call your custom function with the necessary parameters\n",
    "        akhdefo_functions.akhdefo_viewer(\n",
    "            path_to_dem_file='./data/morenny/basemap.tif',\n",
    "            raster_file=temp_outputname,\n",
    "            output_folder='./data/morenny/radar/Figs_analysis/',\n",
    "            title=file_name,\n",
    "            pixel_resolution_meters=None,\n",
    "            output_file_name=file_name,\n",
    "            alpha=0.4,\n",
    "            unit_conversion=None,\n",
    "            no_data_mask=True,\n",
    "            colormap='spring_r',\n",
    "            min_value=None,\n",
    "            max_value=None,\n",
    "            normalize=True,\n",
    "            colorbar_label='meter/year',\n",
    "            show_figure=True,\n",
    "            aspect_raster='./data/morenny/radar/VEL_Folder/aspect.tif',\n",
    "            cmap_aspect='hsv',\n",
    "            step=5\n",
    "        )\n",
    "\n",
    "        ds = None\n",
    "        band=None\n",
    "        os.remove(temp_outputname)\n",
    "         # Find date in the filename\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import ee\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "import seaborn as sns  # For enhanced plot styling\n",
    "from scipy.stats import linregress\n",
    "import geopandas as gpd \n",
    "\n",
    "\n",
    "# Initialize the Earth Engine module.\n",
    "ee.Initialize()\n",
    "\n",
    "# Define your area of interest (AOI) using latitude and longitude\n",
    "lat = 42.99\n",
    "lon = 76.99\n",
    "point = ee.Geometry.Point([lon, lat])\n",
    "\n",
    "# Define a 5km by 5km square around the point\n",
    "#square = point.buffer(500).bounds()  # Buffer by 4000 meters (4 km) and get bounds\n",
    "square=ee.Geometry.BBox(76.9868751901, 42.9914296961, 77.0048813882, 43.0093232151)\n",
    "\n",
    "\n",
    "\n",
    "# Cloud mask function\n",
    "def maskL8sr(col):\n",
    "    cloudShadowBitMask = 1 << 3\n",
    "    cloudsBitMask = 1 << 5\n",
    "    qa = col.select('pixel_qa')\n",
    "    mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0).And(qa.bitwiseAnd(cloudsBitMask).eq(0))\n",
    "    return col.updateMask(mask)\n",
    "\n",
    "# Load and process the Landsat 8 Image Collection\n",
    "col = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR').map(maskL8sr).filterDate('2017-03-01', '2024-10-01').filterBounds(square)\n",
    "\n",
    "# Function to calculate LST for each image in the collection\n",
    "def calculateLST(image):\n",
    "    ndvi = image.normalizedDifference(['B5', 'B4']).rename('NDVI')\n",
    "    a = ee.Number(0.004)\n",
    "    b = ee.Number(0.986)\n",
    "    LST = image.expression('(Tb/(1 + (0.00115 * (Tb / 1.438)) * log(Ep)))-273.15', {\n",
    "      'Tb': image.select('B10').multiply(0.1),\n",
    "      'Ep': ndvi.multiply(a).add(b)\n",
    "    }).rename('LST')\n",
    "    return image.addBands(LST)\n",
    "\n",
    "# Add LST band to each image in the collection\n",
    "lstCol = col.map(calculateLST)\n",
    "\n",
    "# Function to add a 'year' property to each image\n",
    "def addYear(image):\n",
    "    date = ee.Date(image.get('system:time_start'))\n",
    "    year = ee.Number(date.get('year')).toInt()\n",
    "    return image.set('year', year)\n",
    "\n",
    "# Apply the addYear function to each image in the collection\n",
    "lstCol = lstCol.map(addYear)\n",
    "\n",
    "# Filter for July and August\n",
    "julAugCol = lstCol.filter(ee.Filter.calendarRange(7, 8, 'month'))\n",
    "julAugCol=lstCol\n",
    "\n",
    "\n",
    "# Calculate the mean LST for each year\n",
    "yearlyMean = ee.ImageCollection.fromImages(\n",
    "  ee.List.sequence(2017, 2023).map(lambda year: \n",
    "    julAugCol.filter(ee.Filter.eq('year', year)).mean().set('year', year)\n",
    "  )\n",
    ")\n",
    "\n",
    "# Function to extract data\n",
    "def extract_data(image):\n",
    "    mean_dict = image.reduceRegion(reducer=ee.Reducer.mean(), geometry=square, scale=30).getInfo()\n",
    "    return mean_dict.get('LST', None)  # Use get method with a default value of None\n",
    "\n",
    "# Extract the mean LST for each year and convert to a Pandas DataFrame\n",
    "data = []\n",
    "years = []\n",
    "for year in range(2017, 2021):\n",
    "    image = ee.Image(yearlyMean.filter(ee.Filter.eq('year', year)).first())\n",
    "    lst_value = extract_data(image)\n",
    "    if lst_value is not None:\n",
    "        data.append(lst_value)\n",
    "        years.append(year)\n",
    "\n",
    "df = pd.DataFrame({'Year': years, 'LST': data})\n",
    "\n",
    "\n",
    "import pandas as pd\n",
    "import plotly.graph_objects as go\n",
    "import plotly.express as px\n",
    "\n",
    "\n",
    "# Fitting a linear model to the data\n",
    "slope, intercept, r_value, p_value, std_err = linregress(df['Year'], df['LST'])\n",
    "\n",
    "# Calculate the line of best fit\n",
    "df['Trendline'] = intercept + slope * df['Year']\n",
    "\n",
    "# Create a Plotly figure\n",
    "fig = px.scatter(df, x='Year', y='LST', title='Mean LST for July and August (2017-2021) with Trendline')\n",
    "\n",
    "# Add a scatter plot for Mean LST\n",
    "fig.add_trace(go.Scatter(x=df['Year'], y=df['LST'], mode='markers', name='Mean LST'))\n",
    "\n",
    "# Add a trendline\n",
    "fig.add_trace(go.Scatter(x=df['Year'], y=df['Trendline'], mode='lines', name='Trendline'))\n",
    "\n",
    "# Calculate the rate of change annotation\n",
    "rate_of_change = slope\n",
    "\n",
    "# Annotate the rate of change in the legend\n",
    "fig.add_trace(go.Scatter(x=[None], y=[None], mode='markers', marker=dict(size=0),\n",
    "                         name=f'Rate of Change: {rate_of_change:.2f}°C/year'))\n",
    "\n",
    "# Customize the appearance\n",
    "fig.update_traces(marker=dict(size=8))\n",
    "fig.update_layout(legend_title_text='Legend')\n",
    "\n",
    "# Show the plot\n",
    "fig.show()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import seaborn as sns\n",
    "from scipy.stats import linregress\n",
    "\n",
    "# Load the CSV file\n",
    "file_path = './data/morenny/LST/Mean_LST_Jul_Aug_2017_to_2023.csv'\n",
    "data = pd.read_csv(file_path)\n",
    "\n",
    "# Display the first few rows of the dataframe to understand its structure\n",
    "data.head()\n",
    "\n",
    "# Selecting relevant columns\n",
    "data = data[['year', 'LST']]\n",
    "\n",
    "# Removing any null/NaN values\n",
    "data.dropna(inplace=True)\n",
    "\n",
    "# Ensuring 'year' is an integer\n",
    "data['year'] = data['year'].astype(int)\n",
    "\n",
    "# Correcting the line plot code\n",
    "plt.figure(figsize=(10, 6))\n",
    "sns.scatterplot(data=data, x='year', y='LST', color='blue', s=50)\n",
    "\n",
    "# Plotting the regression line\n",
    "sns.lineplot(x=data['year'], y=line, color='red')\n",
    "\n",
    "# Annotating the rate of change\n",
    "rate_of_change = f\"Rate of Change: {slope:.2f} °C/year\"\n",
    "plt.text(data['year'].min(), data['LST'].max(), rate_of_change, fontsize=12, color='green')\n",
    "\n",
    "# Setting plot titles and labels\n",
    "plt.title('Yearly Mean Land Surface Temperature (LST) Trend', fontsize=14)\n",
    "plt.xlabel('Year', fontsize=12)\n",
    "plt.ylabel('Mean LST (°C)', fontsize=12)\n",
    "plt.grid(True)\n",
    "\n",
    "# Show plot\n",
    "plt.show()\n",
    "\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "akhdefov2",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
