<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>akhdefo_functions.Akhdefo_GOI &#8212; AkhDefo Software 2.3.125 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/flask.css?v=b87c8d14" />
    <script src="../../_static/documentation_options.js?v=cdd0b548"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Akhdefo</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">akhdefo_functions.Akhdefo_GOI</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for akhdefo_functions.Akhdefo_GOI</h1><div class="highlight"><pre>
<span></span><span class="c1">###Start###</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">gdal</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">from</span> <span class="nn">pykrige.ok</span> <span class="kn">import</span> <span class="n">OrdinaryKriging</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">generic_filter</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="kn">import</span> <span class="n">StandardScaler</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">gaussian</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">listdir</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">join</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_pdf</span> <span class="kn">import</span> <span class="n">PdfPages</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1.inset_locator</span> <span class="kn">import</span> <span class="n">inset_axes</span>
<span class="kn">from</span> <span class="nn">rasterio.features</span> <span class="kn">import</span> <span class="n">geometry_mask</span>
<span class="kn">from</span> <span class="nn">rasterio.transform</span> <span class="kn">import</span> <span class="n">from_origin</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
<span class="kn">from</span> <span class="nn">skimage.metrics</span> <span class="kn">import</span> <span class="n">structural_similarity</span> <span class="k">as</span> <span class="n">ssim</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">import</span> <span class="nn">akhdefo_functions</span>
<span class="kn">from</span> <span class="nn">akhdefo_functions</span> <span class="kn">import</span> <span class="n">Crop_to_AOI</span>
<span class="kn">from</span> <span class="nn">akhdefo_functions.Akhdefo_Utilities</span> <span class="kn">import</span> <span class="n">Auto_Variogram</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">rasterio.windows</span> <span class="kn">import</span> <span class="n">from_bounds</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span>
<span class="kn">from</span> <span class="nn">rasterio.mask</span> <span class="kn">import</span> <span class="n">mask</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">rasterio.features</span> <span class="kn">import</span> <span class="n">geometry_mask</span>
<span class="kn">from</span> <span class="nn">rasterio.transform</span> <span class="kn">import</span> <span class="n">from_origin</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>
<span class="kn">import</span> <span class="nn">cmocean</span>
<span class="kn">import</span> <span class="nn">earthpy.plot</span> <span class="k">as</span> <span class="nn">ep</span>
<span class="kn">import</span> <span class="nn">earthpy.spatial</span> <span class="k">as</span> <span class="nn">es</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># Import necessary packages</span>
<span class="kn">import</span> <span class="nn">rasterio</span> <span class="k">as</span> <span class="nn">rio</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>


<div class="viewcode-block" id="mask_raster_with_template">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.mask_raster_with_template">[docs]</a>
<span class="k">def</span> <span class="nf">mask_raster_with_template</span><span class="p">(</span><span class="n">input_raster_path</span><span class="p">,</span> <span class="n">mask_raster_path</span><span class="p">,</span> <span class="n">noData_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Masks a georeferenced raster file using a binary raster mask template.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - input_raster_path (str): Path to the input georeferenced raster file.</span>
<span class="sd">    - mask_raster_path (str): Path to the binary raster mask template.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None. The input raster file will be replaced by the masked raster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Open the input raster and mask raster</span>
    <span class="n">input_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">input_raster_path</span><span class="p">,</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GA_ReadOnly</span><span class="p">)</span>
    <span class="n">mask_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">mask_raster_path</span><span class="p">,</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GA_ReadOnly</span><span class="p">)</span>

    <span class="c1"># Create memory target raster with same dimensions as input raster</span>
    <span class="n">mem_drv</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GetDriverByName</span><span class="p">(</span><span class="s1">&#39;MEM&#39;</span><span class="p">)</span>
    <span class="n">target_ds</span> <span class="o">=</span> <span class="n">mem_drv</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GDT_Byte</span><span class="p">)</span>
    <span class="n">target_ds</span><span class="o">.</span><span class="n">SetGeoTransform</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">())</span>
    <span class="n">target_ds</span><span class="o">.</span><span class="n">SetProjection</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">())</span>

    <span class="c1"># Reproject mask raster to match input raster</span>
    <span class="n">gdal</span><span class="o">.</span><span class="n">ReprojectImage</span><span class="p">(</span><span class="n">mask_ds</span><span class="p">,</span> <span class="n">target_ds</span><span class="p">,</span> <span class="n">mask_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">(),</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">(),</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GRA_NearestNeighbour</span><span class="p">)</span>
    <span class="n">mask_band</span> <span class="o">=</span> <span class="n">target_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>

    <span class="c1"># Create a temporary file to store masked raster</span>
    <span class="n">temp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.tif&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># Loop through bands in input raster and apply mask</span>
    <span class="n">out_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GetDriverByName</span><span class="p">(</span><span class="s1">&#39;GTiff&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">temp_file</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterCount</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">DataType</span><span class="p">)</span>
    <span class="n">out_ds</span><span class="o">.</span><span class="n">SetGeoTransform</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">())</span>
    <span class="n">out_ds</span><span class="o">.</span><span class="n">SetProjection</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">input_band_data</span> <span class="o">=</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="n">band</span><span class="p">)</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>
        <span class="n">input_band_data</span><span class="p">[</span><span class="n">mask_band</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">noData_value</span>  <span class="c1"># Set pixels to 0 where mask is 0</span>

        <span class="n">out_band</span> <span class="o">=</span> <span class="n">out_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
        <span class="n">out_band</span><span class="o">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">input_band_data</span><span class="p">)</span>
        <span class="n">out_band</span><span class="o">.</span><span class="n">FlushCache</span><span class="p">()</span>

    <span class="n">input_ds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mask_ds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">out_ds</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Replace original raster with the masked raster</span>
    <span class="c1"># os.remove(input_raster_path)</span>
    <span class="c1"># os.rename(temp_file, input_raster_path)</span>
    
    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_file</span><span class="p">,</span> <span class="n">input_raster_path</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_file</span><span class="p">)</span></div>




<div class="viewcode-block" id="mask_all_rasters_in_directory">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.mask_all_rasters_in_directory">[docs]</a>
<span class="k">def</span> <span class="nf">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">mask_raster_path</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Masks all georeferenced raster files in a specified directory using a binary raster mask template.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        - directory (str): Path to the directory containing the georeferenced raster files.</span>
<span class="sd">        - mask_raster_path (str): Path to the binary raster mask template.</span>

<span class="sd">    Returns:</span>
<span class="sd">        -Each raster file in the specified directory will be replaced by its corresponding masked raster</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>  <span class="c1"># This will only list files/directories in the given directory</span>
        <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">)):</span>
            <span class="n">input_raster_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">mask_raster_with_template</span><span class="p">(</span><span class="n">input_raster_path</span><span class="p">,</span> <span class="n">mask_raster_path</span><span class="p">)</span></div>





<span class="c1">#Calculate Linear Velocity for each data point</span>
<div class="viewcode-block" id="linear_VEL">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.linear_VEL">[docs]</a>
<span class="k">def</span> <span class="nf">linear_VEL</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">dnames</span><span class="p">):</span>
    
    <span class="n">dd_list</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dnames</span><span class="p">]</span>
    <span class="n">dates_list</span><span class="o">=</span><span class="p">([</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dd_list</span><span class="p">])</span>
    <span class="n">days_num</span><span class="o">=</span><span class="p">[(</span> <span class="p">((</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dates_list</span><span class="p">]</span>
    <span class="n">days_num</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnames</span><span class="p">)))</span>
    <span class="n">dslope</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">std_slope</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">dr</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1">#if index==0:</span>
        <span class="n">rows</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">row_values</span><span class="o">=</span><span class="n">rows</span>
        <span class="c1"># dfr = pd.DataFrame(dr).transpose()</span>
        <span class="c1"># dfr = dfr.loc[:, ~dfr.columns.str.contains(&#39;^Unnamed&#39;)]</span>
    
        <span class="c1">#slopeVEL=best_fit_slope_and_intercept(days_num, row_values)</span>
        <span class="c1">#print(&quot;slope&quot;, slopeVEL[0])</span>
        <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">days_num</span><span class="p">,</span> <span class="n">row_values</span><span class="p">)</span>
        <span class="n">dslope</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope</span><span class="p">)</span>
        <span class="n">std_slope</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std_err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dslope</span><span class="p">,</span> <span class="n">std_slope</span></div>


<span class="c1"># def replace_outliers_with_nan_zscore(gdf, column_name, threshold):</span>
<span class="c1">#     # Create a copy of the GeoDataFrame to avoid modifying the original</span>
<span class="c1">#     #modified_geodataframe = geodataframe.copy()</span>

<span class="c1">#     # Calculate Z-scores for the specified column</span>
<span class="c1">#     z_scores = np.abs(zscore(gdf[column_name]))</span>

<span class="c1">#     # Replace outliers with NaN values based on the threshold</span>
<span class="c1">#     gdf.loc[z_scores &gt; threshold, column_name] = np.nan</span>

<span class="c1">#     return gdf</span>

<span class="c1"># import numpy as np</span>
<span class="c1"># import geopandas as gpd</span>
<span class="c1"># import gstools as gs</span>
<span class="c1"># import matplotlib.pyplot as plt</span>

<span class="c1"># # Function to fit variogram models and visualize them</span>
<span class="c1"># def fit_variogram_models(x, y, z, latlon=False , show_plot=False):</span>
<span class="c1">#     bin_center, gamma = gs.vario_estimate((x, y), z, latlon=latlon)</span>
    
<span class="c1">#     # Models to test</span>
<span class="c1">#     models = {</span>
<span class="c1">#         &quot;Gaussian&quot;: gs.Gaussian,</span>
<span class="c1">#         &quot;Exponential&quot;: gs.Exponential,</span>
<span class="c1">#         &quot;Matern&quot;: gs.Matern,</span>
<span class="c1">#         &quot;Integral&quot;: gs.Integral,</span>
<span class="c1">#         &quot;Cubic&quot;: gs.Cubic,</span>
<span class="c1">#         &quot;Stable&quot;: gs.Stable,</span>
<span class="c1">#         &quot;Rational&quot;: gs.Rational,</span>
<span class="c1">#         &quot;Spherical&quot;: gs.Spherical,</span>
<span class="c1">#         &quot;SuperSpherical&quot;: gs.SuperSpherical,</span>
<span class="c1">#         &quot;JBessel&quot;: gs.JBessel,</span>
<span class="c1">#         &quot;HyperSpherical&quot;: gs.HyperSpherical,</span>
<span class="c1">#         &quot;TPLSimple&quot;: gs.TPLSimple</span>
<span class="c1">#     }</span>

<span class="c1">#     scores = {}</span>
<span class="c1">#     fig, ax = plt.subplots(figsize=(10, 5))</span>
<span class="c1">#     ax.scatter(bin_center, gamma, color=&quot;k&quot;, label=&quot;Empirical&quot;)</span>

<span class="c1">#     best_model, best_score, best_fit = None, -10, None</span>
    
<span class="c1">#     for model_name, Model in models.items():</span>
<span class="c1">#         try:</span>
<span class="c1">#             fit_model = Model(dim=2)</span>
<span class="c1">#             _, _, r2 = fit_model.fit_variogram(bin_center, gamma, return_r2=True)</span>
<span class="c1">#             scores[model_name] = r2</span>
            
<span class="c1">#             if r2 &gt; best_score:</span>
<span class="c1">#                 best_score = r2</span>
<span class="c1">#                 best_model = model_name</span>
<span class="c1">#                 best_fit = fit_model</span>
            
<span class="c1">#             # Plot the model</span>
<span class="c1">#             fit_model.plot(x_max=max(bin_center), ax=ax, label=f&quot;{model_name} (R2: {r2:.5f})&quot;)</span>
<span class="c1">#         except Exception as e:</span>
<span class="c1">#             print(f&quot;Error with model {model_name}: {e}&quot;)</span>
    
<span class="c1">#     ax.legend()</span>
<span class="c1">#     ax.set_title(f&#39;Variogram Models with Fitted Data, Best Model= {best_model}, with score{best_score}&#39;)</span>
<span class="c1">#     if show_plot== True:</span>
<span class="c1">#         plt.show()</span>
<span class="c1">#     else:</span>
<span class="c1">#         plt.close()</span>
<span class="c1">#     return best_model, best_score, scores, best_fit</span>
<span class="c1"># def interpolate_kriging_nans_geodataframe(data, threshold=None, variogram_model=None, </span>
<span class="c1"># out_fileName=None, plot=False, Total_days=None, VEL_scale=None, VEL_Mode=None):</span>
    
<span class="c1">#     if isinstance(data, str):</span>
<span class="c1">#         if data[-4:] == &#39;.shp&#39;:</span>
<span class="c1">#             gdf = gpd.read_file(data)</span>

<span class="c1">#             geom=gdf[&#39;geometry&#39;]</span>
<span class="c1">#             crs_ini=gdf.crs</span>
           
<span class="c1">#             out_fileName = data</span>
<span class="c1">#             Total_days=Total_days</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise ValueError(&quot;Unsupported file format.&quot;)</span>
<span class="c1">#     elif isinstance(data, gpd.GeoDataFrame):</span>
<span class="c1">#         gdf = data</span>
<span class="c1">#         out_fileName = None</span>
<span class="c1">#     else:</span>
<span class="c1">#         raise ValueError(&quot;Unsupported data type.&quot;)</span>

<span class="c1">#     unwanted_cols = [&#39;CODE&#39;,&#39;geometry&#39;, &#39;x&#39;, &#39;y&#39;, &#39;VEL&#39;, &#39;VEL_STD&#39;]</span>
<span class="c1">#     columns_to_interpolate = [col for col in gdf.columns if col not in unwanted_cols]</span>


<span class="c1">#     for col in columns_to_interpolate:</span>
<span class="c1">#         if threshold is not None:</span>
<span class="c1">#             gdf = replace_outliers_with_nan_zscore(gdf, col, threshold)</span>
<span class="c1">#         try:</span>
<span class="c1">#             known_data = gdf[~gdf[col].isna()]</span>
<span class="c1">#             unknown_data = gdf[gdf[col].isna()]</span>

<span class="c1">#             known_coords = [(geom.x, geom.y) for geom in known_data.geometry]</span>
<span class="c1">#             unknown_coords = [(geom.x, geom.y) for geom in unknown_data.geometry]</span>


<span class="c1">#             #known_coords = list(known_data.geometry.apply(lambda geom: (geom.x, geom.y)))</span>
<span class="c1">#             known_values =  [x for x in known_data[col]]</span>

<span class="c1">#             #unknown_coords = list(unknown_data.geometry.apply(lambda geom: (geom.x, geom.y)))</span>
<span class="c1">#             if variogram_model is None:</span>
<span class="c1">#                 best_model, best_score, scores, best_fit=fit_variogram_models(gdf.x, gdf.y, gdf[col], latlon=False, show_plot=plot)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 best_fit=variogram_model</span>
<span class="c1">#             ok = OrdinaryKriging(</span>
<span class="c1">#                 [coord[0] for coord in known_coords],</span>
<span class="c1">#                 [coord[1] for coord in known_coords],</span>
<span class="c1">#                 known_values,</span>
<span class="c1">#                 variogram_model=best_fit,</span>
<span class="c1">#                 verbose=False</span>
<span class="c1">#             )</span>

<span class="c1">#             interpolated_values, _ = ok.execute(</span>
<span class="c1">#                 &#39;points&#39;,</span>
<span class="c1">#                 [coord[0] for coord in unknown_coords],</span>
<span class="c1">#                 [coord[1] for coord in unknown_coords]</span>
<span class="c1">#             )</span>

<span class="c1">#             gdf.loc[unknown_data.index, col] = interpolated_values</span>
<span class="c1">#         except Exception as e:</span>
<span class="c1">#             print(f&quot;Error with kriging interpolation: {e}, interpolation performed using pandas interpolation&quot;)</span>
        
<span class="c1">#         gdf[col]=gdf[col].interpolate()</span>
<span class="c1">#     # Interpolating NaN values in the subset DataFrame</span>
<span class="c1">#     gdf[columns_to_interpolate] = gdf[columns_to_interpolate].interpolate(axis=1, limit_direction=&#39;both&#39;)</span>
        
<span class="c1">#     zcol=columns_to_interpolate[0]</span>
<span class="c1">#     #zcol=[gdf[z] for z in columns_to_interpolate]</span>
<span class="c1">#     ######################</span>
<span class="c1">#     if isinstance(data, str):</span>
<span class="c1">#         if data[-4:] == &#39;.shp&#39;:</span>
<span class="c1">#             # Reset the index and convert it to a column</span>
<span class="c1">#             gdf = gdf.reset_index()</span>

<span class="c1">#             # Rename the index column to &quot;CODE&quot;</span>
<span class="c1">#             gdf.rename(columns={&#39;index&#39;: &#39;CODE&#39;}, inplace=True)</span>

            

<span class="c1">#             if VEL_Mode==&#39;linear&#39; and VEL_scale==&#39;year&#39;:</span>
<span class="c1">#                 VEL, VEL_STD=linear_VEL(gdf[columns_to_interpolate], columns_to_interpolate)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL&#39;]= gdf[&#39;VEL&#39;]/ Total_days * 365</span>
            
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 365</span>

<span class="c1">#             if VEL_Mode==&#39;mean&#39; and VEL_scale==&#39;year&#39;:</span>
<span class="c1">#                 VEL=gdf[columns_to_interpolate].mean(axis=1)</span>
<span class="c1">#                 VEL_STD=gdf[columns_to_interpolate].std(axis=1)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;]/ Total_days * 365</span>
                
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD</span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;] / Total_days * 365</span>

<span class="c1">#             if VEL_Mode==&#39;linear&#39; and VEL_scale==&#39;month&#39;:</span>
<span class="c1">#                 VEL, VEL_STD=linear_VEL(gdf[columns_to_interpolate], columns_to_interpolate)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;]/ Total_days * 30</span>

<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 30</span>

<span class="c1">#             if VEL_Mode==&#39;mean&#39; and VEL_scale==&#39;month&#39;:</span>
<span class="c1">#                 VEL=gdf[columns_to_interpolate].mean(axis=1)</span>
<span class="c1">#                 VEL_STD=gdf[columns_to_interpolate].std(axis=1)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;] / Total_days * 30</span>

<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 30</span>

<span class="c1">#             if VEL_Mode==&#39;linear&#39; and VEL_scale==None:</span>
<span class="c1">#                 VEL, VEL_STD=linear_VEL(gdf[columns_to_interpolate], columns_to_interpolate)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>

<span class="c1">#             if VEL_Mode==&#39;mean&#39; and VEL_scale==None:</span>
<span class="c1">#                 VEL=gdf[columns_to_interpolate].mean(axis=1)</span>
<span class="c1">#                 VEL_STD=gdf[columns_to_interpolate].std(axis=1)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL</span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD</span>

<span class="c1">#             column_order = columns_to_interpolate  # New columns added at the beginning</span>
<span class="c1">#             # # Insert new columns at the beginning of the list</span>
<span class="c1">#             columns_to_insert = [&#39;CODE&#39;, &#39;x&#39;, &#39;y&#39;, &#39;VEL&#39;, &#39;VEL_STD&#39;]  # Inserted in this order</span>
<span class="c1">#             col_geo=[&#39;geometry&#39;]</span>
<span class="c1">#             column_order= columns_to_insert + columns_to_interpolate+col_geo</span>
<span class="c1">#             gdf=gdf[column_order]</span>
            
<span class="c1">#             # Get the CRS of the GeoDataFrame</span>
<span class="c1">#             gdf.crs=crs_ini</span>

    

<span class="c1">#     if out_fileName is not None:</span>

<span class="c1">#         gdf.to_file(out_fileName)</span>

<span class="c1">#     if plot is not False:</span>

<span class="c1">#         for col in columns_to_interpolate:</span>
<span class="c1">#             fig, axes = plt.subplots(1, 2, figsize=(12, 6))</span>

<span class="c1">#             gdf.plot(ax=axes[0], column=col, cmap=&#39;rainbow&#39;, legend=True, markersize=5)</span>
<span class="c1">#             axes[0].set_title(f&#39;Before Interpolation - {col}&#39;)</span>

<span class="c1">#             gdf.plot(ax=axes[1], column=col, cmap=&#39;rainbow&#39;, legend=True, markersize=5)</span>
<span class="c1">#             axes[1].set_title(f&#39;After Interpolation - {col}&#39;)</span>

<span class="c1">#             plt.tight_layout()</span>
<span class="c1">#             plt.show()</span>

    
<span class="c1">#     return np.array(gdf.x) , np.array(gdf.y) , np.array(gdf[zcol]), gdf</span>
<span class="c1"># # Usage example</span>
<span class="c1"># shapefile_path = &#39;flowx1.shp&#39;</span>
<span class="c1"># x, y, z=interpolate_kriging_nans_geodataframe(shapefile_path=&#39;flowx.shp&#39;, threshold=None, variogram_model=&#39;gaussian&#39;, </span>
<span class="c1"># out_fileName=&#39;flow11&#39;, plot=True)</span>
<span class="c1">###############################################################################################</span>




<span class="c1">######################################</span>

<div class="viewcode-block" id="process_shapefile_with_rasters">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.process_shapefile_with_rasters">[docs]</a>
<span class="k">def</span> <span class="nf">process_shapefile_with_rasters</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">,</span> <span class="n">rasterfile_paths</span><span class="p">):</span>
    <span class="c1"># Load the shapefile</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

    <span class="c1"># Process rasterfile paths</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">rasterfile_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterfile_paths</span><span class="p">]</span>
    <span class="n">raster_paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.tif&#39;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span>
    <span class="n">rasterfile_paths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">raster_paths</span><span class="p">]</span>

    <span class="c1"># Load rasters</span>
    <span class="n">rasters</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">rasterfile_paths</span><span class="p">]</span>

    <span class="c1"># Extract &#39;D&#39; columns</span>
    <span class="n">d_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)]</span>

    <span class="c1"># Map rasters to &#39;D&#39; columns</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">band</span><span class="p">)</span> <span class="k">for</span> <span class="n">band</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)}</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">):</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">raster</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">rasters</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of provided rasters or bands does not match the number of &#39;D&#39; columns in the shapefile.&quot;</span><span class="p">)</span>

    <span class="c1"># Sample values for each &#39;D&#39; column</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
        <span class="n">raster</span><span class="p">,</span> <span class="n">band</span> <span class="o">=</span> <span class="n">raster_band_mapping</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">sampled_values</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">sampled_values</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># # # Check for NaN values in &#39;D&#39; columns</span>
    <span class="c1"># all_nan = gdf[d_columns].isna().all(axis=1)</span>
    <span class="c1"># # Drop all rows with any NaN values</span>
    <span class="c1"># gdf.dropna(inplace=True)</span>
    
    <span class="c1"># gdf = gdf.dropna()</span>
    <span class="n">gdf</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;ssim_mean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;ssim_std&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Drop the columns</span>
    <span class="c1">#gdf = gdf.drop(columns=d_columns)</span>
    

    <span class="c1"># # Correct displacement to a stable point</span>
    <span class="c1"># try:</span>
    <span class="c1">#     #VEL, VEL_STD_series = linear_VEL(gdf[d_columns], d_columns)</span>
    <span class="c1">#     # Calculate mean, ignoring NaN values</span>
    <span class="c1">#     # Calculate mean, ignoring NaN values</span>
    <span class="c1">#     VEL = gdf[d_columns].mean(axis=1)</span>

    <span class="c1">#     # Calculate standard deviation, ignoring NaN values</span>
    <span class="c1">#     VEL_STD_series = gdf[d_columns].std(axis=1)</span>
        
    <span class="c1">#     gdf[&#39;ssim_mean&#39;]=VEL</span>
    <span class="c1">#     gdf[&#39;ssim_std&#39;]=VEL_STD_series</span>
    <span class="c1">#     # Drop the specified columns</span>
    <span class="c1">#     #gdf = gdf.drop(columns=d_columns, errors=&#39;ignore&#39;)</span>
    <span class="c1">#     # VEL_STD_series = pd.Series(VEL_STD_series)</span>
    <span class="c1">#     # min_std_dev = VEL_STD_series.min()</span>
    <span class="c1">#     # filtered_indices = VEL_STD_series[VEL_STD_series == min_std_dev].index</span>
    <span class="c1">#     # avg_velocities = gdf[d_columns].loc[filtered_indices].mean(axis=1)</span>
    <span class="c1">#     # reference_index = avg_velocities.idxmin()</span>
    <span class="c1"># except Exception as e:</span>
    <span class="c1">#     print(&quot;Error in displacement correction:&quot;, e)</span>
        <span class="c1">#reference_index = None</span>

    <span class="k">return</span> <span class="n">gdf</span></div>


<div class="viewcode-block" id="find_best_match">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.find_best_match">[docs]</a>
<span class="k">def</span> <span class="nf">find_best_match</span><span class="p">(</span><span class="n">gdf</span><span class="p">):</span>
    
   

    <span class="n">gdf_temp</span><span class="o">=</span><span class="n">gdf</span>
    <span class="c1"># Load your GeoDataFrame</span>
    <span class="c1"># Assuming &#39;gdf&#39; is your GeoDataFrame with a &#39;VEL&#39; column and geometry</span>
    <span class="c1"># gdf_temp[&#39;VEL&#39;]=gdf_temp[&#39;VEL&#39;].abs()</span>
    <span class="c1"># gdf_temp[&#39;VEL_STD&#39;]=gdf_temp[&#39;VEL_STD&#39;].abs()</span>
    
    <span class="c1"># Extract the coordinates in meters after reprojection</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gdf_temp</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">gdf_temp</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="p">)))</span>

    <span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="kn">import</span> <span class="n">KMeans</span>

    <span class="c1"># Number of clusters</span>
    <span class="n">n_clusters</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="c1"># Run K-Means clustering</span>
    <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">gdf_temp</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="c1"># Calculate the average &quot;VEL&quot; for each cluster, excluding noise (cluster = -1)</span>
    <span class="n">cluster_averages_std</span> <span class="o">=</span> <span class="n">gdf_temp</span><span class="p">[</span><span class="n">gdf_temp</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cluster&#39;</span><span class="p">)[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">cluster_averages</span> <span class="o">=</span> <span class="n">gdf_temp</span><span class="p">[</span><span class="n">gdf_temp</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;cluster&#39;</span><span class="p">)[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    
    <span class="c1"># Identify the cluster with the lowest average &quot;VEL&quot;</span>
    <span class="n">lowest_avg_vel_cluster</span> <span class="o">=</span> <span class="n">cluster_averages</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">cluster_averages_std</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>

    <span class="c1"># Find the point with the minimum &quot;VEL&quot; within the lowest average &quot;VEL&quot; cluster</span>
    <span class="n">min_vel_point</span> <span class="o">=</span> <span class="n">gdf_temp</span><span class="p">[(</span><span class="n">gdf_temp</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">lowest_avg_vel_cluster</span><span class="p">)</span> <span class="o">&amp;</span>  <span class="p">(</span><span class="n">gdf_temp</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gdf_temp</span><span class="p">[</span><span class="n">gdf_temp</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">lowest_avg_vel_cluster</span><span class="p">][</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())]</span>

    <span class="c1"># Get the index of this point</span>
    <span class="n">min_vel_point_index</span> <span class="o">=</span> <span class="n">min_vel_point</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># If you want only the smallest index value</span>
    <span class="n">min_index</span> <span class="o">=</span> <span class="n">min_vel_point_index</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

    <span class="c1"># If you want just the first index (as an example)</span>
    <span class="n">best_match_index</span> <span class="o">=</span> <span class="n">min_vel_point_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">best_match_index</span></div>



<span class="c1">######################################3</span>



<span class="c1">#############################</span>


<div class="viewcode-block" id="calculate_slopes_std_and_residuals">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.calculate_slopes_std_and_residuals">[docs]</a>
<span class="k">def</span> <span class="nf">calculate_slopes_std_and_residuals</span><span class="p">(</span><span class="n">geodataframe</span><span class="p">):</span>
    <span class="n">L_slopes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">M_slopes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_std_devs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">M_std_devs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Extract the date columns (columns starting with &#39;D&#39;)</span>
    <span class="n">date_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)]</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">date_columns</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">days_since_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">dates</span> <span class="o">-</span> <span class="n">dates</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">days</span>


    <span class="c1"># Interpolate date_columns row-wise</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">row</span><span class="p">[</span><span class="n">date_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">date_columns</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="n">date_columns</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;ffill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">row</span><span class="p">[</span><span class="n">date_columns</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="s1">&#39;bfill&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">geodataframe</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="n">date_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">date_columns</span><span class="p">]</span>
        
    <span class="c1"># Iterate through each row in the GeoDataFrame</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">date_columns</span><span class="p">]</span>
        

        <span class="n">M_slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="n">M_std_devs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># Calculate the slope and intercept using polyfit</span>
        <span class="n">L_slope</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">days_since_start</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">L_slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_slope</span><span class="p">)</span>

        <span class="c1"># Predict values using the regression line and calculate residuals</span>
        <span class="n">predicted_values</span> <span class="o">=</span> <span class="n">L_slope</span> <span class="o">*</span> <span class="n">days_since_start</span> <span class="o">+</span> <span class="n">intercept</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">values</span> <span class="o">-</span> <span class="n">predicted_values</span>

        <span class="c1"># Calculate the standard deviation of the residuals</span>
        <span class="n">L_std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
        <span class="n">L_std_devs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_std_dev</span><span class="p">)</span>

    <span class="c1"># Add the slopes, intercepts, and standard deviations as new columns</span>
    <span class="n">geodataframe</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_slopes</span>
    <span class="n">geodataframe</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_std_devs</span>
    <span class="c1"># geodataframe[&#39;M_VEL&#39;] = M_slopes</span>
    <span class="c1"># geodataframe[&#39;MSTD_VEL&#39;] = M_std_devs</span>

    <span class="c1"># Ensure the returned object is a GeoDataFrame</span>
    <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geodataframe</span><span class="p">)</span></div>




<span class="n">best_match_index</span><span class="o">=</span><span class="kc">None</span>
<div class="viewcode-block" id="update_nodata_values">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.update_nodata_values">[docs]</a>
<span class="k">def</span> <span class="nf">update_nodata_values</span><span class="p">(</span><span class="n">shapefile_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> 
                         <span class="n">rasterfile_paths</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">master_reference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">spatial_ref</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
    
    <span class="k">global</span> <span class="n">best_match_index</span>
    <span class="c1"># Load the shapefile</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>
    <span class="c1">#gdf = gdf.drop(&#39;CODE&#39;)</span>
    <span class="n">crs_ini</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span>

        
    <span class="n">raster_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">)</span>
    
    <span class="n">raster_paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">raster_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.tif&#39;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">rasterfile_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterfile_paths</span><span class="p">]</span>
        <span class="n">rasterfile_paths</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">raster_paths</span><span class="p">]</span>

    <span class="c1"># Load rasters</span>
    <span class="n">rasters</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">rasterfile_paths</span><span class="p">]</span>

    <span class="n">d_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">band</span><span class="p">)</span> <span class="k">for</span> <span class="n">band</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)}</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">):</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">raster</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">rasters</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of provided rasters or bands does not match the number of &#39;D&#39; columns in the shapefile.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
        <span class="n">raster</span><span class="p">,</span> <span class="n">band</span> <span class="o">=</span> <span class="n">raster_band_mapping</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        
        <span class="c1"># Extract x, y coordinates for all rows at once</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># Sample all values for the current column at once</span>
        <span class="n">sampled_values</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
        <span class="c1"># Update the entire column in one go</span>
        <span class="c1">#gdf[col] = [val[0] for val in sampled_values]</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">sampled_values</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    

    <span class="c1"># Check if all cells in d_columns are NaN</span>
    <span class="n">all_nan</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
        <span class="c1"># Interpolate only for rows where all cells in d_columns are not NaN</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">all_nan</span><span class="p">,</span> <span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">all_nan</span><span class="p">,</span> <span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="c1">######</span>
         <span class="c1"># Check if there are still NaN values after interpolation</span>
        <span class="n">still_nan_after_interpolate</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Apply ffill (forward fill) and then bfill (backward fill) as fallbacks</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">still_nan_after_interpolate</span><span class="p">,</span> <span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">still_nan_after_interpolate</span><span class="p">,</span> <span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">ffill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1">#####</span>

    <span class="c1"># Drop rows where all cells in d_columns are NaN</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="o">~</span><span class="n">all_nan</span><span class="p">]</span>
   
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
    <span class="c1"># Check if master_reference is not None before proceeding with the code</span>
    <span class="k">if</span> <span class="n">master_reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    
        <span class="c1">#Subtract columns based on master_reference flag</span>
        <span class="k">if</span> <span class="n">master_reference</span><span class="o">==</span><span class="s1">&#39;single&#39;</span><span class="p">:</span> 
            <span class="n">master_col</span> <span class="o">=</span> <span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#cols_without_mastercol=d_columns[1:]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
                <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">master_col</span><span class="p">]</span>
            <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">master_reference</span><span class="o">==</span><span class="s1">&#39;multiple&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">)):</span>
                
                <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Code to handle the case when master_reference is None</span>
          <span class="c1"># You can add appropriate handling here, or leave it empty if you want to skip the code entirely</span>
        <span class="c1">#gdf[d_columns] = gdf[d_columns].cumsum(axis=1)</span>
        <span class="k">pass</span>
       
    <span class="c1"># Set data types: first d_column to int, the rest to float32</span>
    <span class="c1">#gdf[d_columns[0]] = gdf[d_columns[0]].astype(int)</span>
    <span class="c1">#for col in d_columns[1:]:</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">raster</span> <span class="ow">in</span> <span class="n">rasters</span><span class="p">:</span>
        <span class="n">raster</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1">########################</span>
    
    <span class="c1">#  # Reset the index and convert it to a column</span>
    <span class="c1"># gdf = gdf.reset_index()</span>

    <span class="c1"># # # Rename the index column to &quot;CODE&quot;</span>
    <span class="c1"># gdf=gdf.rename(columns={&#39;index&#39;: &#39;CODE&#39;})</span>
    <span class="n">gdf</span><span class="o">=</span><span class="n">calculate_slopes_std_and_residuals</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">calculate_VEL</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="n">Total_days</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;year&#39;</span><span class="p">:</span>
            <span class="c1"># VEL, VEL_STD=linear_VEL(gdf[d_columns], d_columns)</span>
            <span class="c1"># gdf[&#39;VEL&#39;]=VEL </span>
            <span class="c1">#gdf[&#39;VEL&#39;]= gdf[&#39;VEL&#39;]/ Total_days * 365</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">*</span>  <span class="mf">365.25</span>
        
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 365</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">Total_days</span> <span class="o">*</span> <span class="mf">365.25</span>
            
            
        
        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;year&#39;</span><span class="p">:</span>
            <span class="n">VEL</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">VEL_STD</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL</span> 
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mf">365.25</span>
            <span class="c1">#gdf[&#39;VEL&#39;]= gdf[&#39;VEL&#39;] * 365.25</span>
        
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL_STD</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mf">365.25</span>
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;] * 365</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;month&#39;</span><span class="p">:</span>
            <span class="c1"># VEL, VEL_STD=linear_VEL(gdf[d_columns], d_columns)</span>
            <span class="c1"># gdf[&#39;VEL&#39;]=VEL </span>
            <span class="c1">#gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;]/ Total_days * 30</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">30</span>

            <span class="c1">#gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 30</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">Total_days</span> <span class="o">*</span> <span class="mi">30</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;month&#39;</span><span class="p">:</span>
            <span class="n">VEL</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">VEL_STD</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mi">30</span>

            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL_STD</span> 
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mi">30</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="c1"># VEL, VEL_STD=linear_VEL(gdf[d_columns], d_columns)</span>
            <span class="c1"># gdf[&#39;VEL&#39;]=VEL </span>
            <span class="c1"># gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">VEL</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">VEL_STD</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL_STD</span>
            
        
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="n">gdf</span><span class="o">=</span><span class="n">calculate_VEL</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="n">Total_days</span><span class="p">)</span>
    <span class="c1"># column_order = d_columns  # New columns added at the beginning</span>
    <span class="c1"># # # Insert new columns at the beginning of the list</span>
    <span class="c1"># columns_to_insert = [&#39;CODE&#39;, &#39;x&#39;, &#39;y&#39;, &#39;VEL&#39;, &#39;VEL_STD&#39;]  # Inserted in this order</span>
    <span class="c1"># col_geo=[&#39;geometry&#39;]</span>
    <span class="c1"># column_order= columns_to_insert + d_columns+col_geo</span>
    <span class="c1"># gdf=gdf[column_order]</span>
    
    <span class="c1">########</span>
    <span class="c1"># Extracting x and y coordinates from the &#39;geometry&#39; column</span>
    <span class="c1"># gdf[&#39;x&#39;] = gdf.apply(lambda row: row.geometry.x, axis=1)</span>
    <span class="c1"># gdf[&#39;y&#39;] = gdf.apply(lambda row: row.geometry.y, axis=1)</span>
    <span class="n">col_titles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;VEL&#39;</span><span class="p">,</span> <span class="s1">&#39;VEL_STD&#39;</span> <span class="p">]</span><span class="o">+</span><span class="n">d_columns</span>
    <span class="c1"># Reset the index and convert it to a column</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Rename the index column to &quot;CODE&quot;</span>
    <span class="c1">#gdf = gdf.rename(columns={&#39;index&#39;: &#39;CODE&#39;})</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col_titles</span><span class="p">)</span>
    
    <span class="c1"># Get the CRS of the GeoDataFrame</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">crs_ini</span>
    <span class="c1">#gdf=gdf.dropna()</span>
    
    
    <span class="c1">#####Correct displacement to a stable point############</span>
    <span class="c1"># try:</span>
    <span class="c1">#     # _, VEL_STD_series = linear_VEL(gdf[d_columns], d_columns)</span>
        
    <span class="c1">#     # # Filter points with the lowest standard deviation</span>
    <span class="c1">#     # VEL_STD_series = pd.Series(VEL_STD_series)</span>
    <span class="c1">#     # min_std_dev = VEL_STD_series.min()</span>
    <span class="c1">#     # filtered_indices = VEL_STD_series[VEL_STD_series == min_std_dev].index</span>
        
    <span class="c1">#     # # From the filtered points, select the point with the lowest average velocity</span>
    <span class="c1">#     # avg_velocities = gdf[d_columns].loc[filtered_indices].mean(axis=1)</span>
    <span class="c1">#     # reference_index = avg_velocities.idxmin()</span>
    <span class="k">try</span><span class="p">:</span> 
        
        
        <span class="k">if</span> <span class="n">best_match_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_match_index</span><span class="o">=</span><span class="n">find_best_match</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
        
        <span class="c1"># # Compare each geometry in the GeoDataFrame with the target geometry</span>
        <span class="c1"># for best_match_index, row in gdf.iterrows():</span>
        <span class="c1">#     if row[&#39;geometry&#39;] == geometry_point:</span>
        <span class="c1">#         return best_match_index</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="n">best_match_index</span><span class="p">)</span>
        
        
        <span class="kn">import</span> <span class="nn">shutil</span>
        <span class="c1"># # Create the subdirectory again</span>
        <span class="c1"># os.makedirs(sub_dir_path, exist_ok=True)</span>
        <span class="n">folder_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>
        <span class="n">base_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>
        <span class="n">updated_dir</span><span class="o">=</span><span class="n">folder_directory</span><span class="o">+</span> <span class="s2">&quot;/&quot;</span><span class="o">+</span> <span class="s2">&quot;updated_shapefiles&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">updated_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        
        <span class="c1">#   # Check if the subdirectory exists</span>
        <span class="c1"># if os.path.exists(folder_directory):</span>
        <span class="c1">#     # Remove the existing subdirectory</span>
        <span class="c1">#     shutil.rmtree(folder_directory)</span>
        


        <span class="c1">#####################</span>
        <span class="c1"># Save the updated and interpolated GeodataFrame to a new shapefile or return it</span>
        <span class="n">updated_shapefile_path</span> <span class="o">=</span> <span class="n">updated_dir</span><span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">base_filename</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">updated_shapefile_path</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;ESRI Shapefile&#39;</span><span class="p">)</span>
        
        <span class="c1"># Correct the velocity of each month based on the reference point</span>
        <span class="k">if</span> <span class="n">best_match_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="k">if</span> <span class="n">spatial_ref</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]:</span>
                    <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">]</span>

            <span class="c1"># Extract x, y values of the reference point</span>
            <span class="c1"># ref_point = gdf.geometry.iloc[best_match_index]</span>
            <span class="c1"># ref_point=ref_point</span>
            <span class="c1"># x, y = ref_point.x , ref_point.y</span>
            <span class="n">x</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">]</span>
            <span class="n">y</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">]</span>
            <span class="n">VEL_ref</span><span class="p">,</span> <span class="n">VEL_ref_STD</span><span class="o">=</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">VEL</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">],</span> <span class="n">gdf</span><span class="o">.</span><span class="n">VEL_STD</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">])</span>
            
            <span class="n">dic_data</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;ReferencePoint&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Coordinates&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)},</span> <span class="s2">&quot;VELDATA&quot;</span><span class="p">:{</span> <span class="s2">&quot;VEL&quot;</span><span class="p">:</span> <span class="n">VEL_ref</span><span class="p">,</span> <span class="s2">&quot;VEL_STD&quot;</span><span class="p">:</span> <span class="n">VEL_ref_STD</span><span class="p">}}</span>
            
            <span class="k">def</span> <span class="nf">dict_to_xml</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">Element</span><span class="p">,</span> <span class="n">SubElement</span><span class="p">,</span> <span class="n">tostring</span>
                <span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">inner_key</span><span class="p">,</span> <span class="n">inner_value</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inner_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="n">coord</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">inner_key</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">coord_key</span><span class="p">,</span> <span class="n">coord_value</span> <span class="ow">in</span> <span class="n">inner_value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">coord_element</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">coord_key</span><span class="p">)</span>
                                <span class="n">coord_element</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">coord_value</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">element</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">inner_key</span><span class="p">)</span>
                            <span class="n">element</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">inner_value</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">))</span><span class="o">.</span><span class="n">toprettyxml</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>
            <span class="n">xml_name</span><span class="o">=</span><span class="n">updated_shapefile_path</span> <span class="o">+</span> <span class="s2">&quot;.xml&quot;</span>
            <span class="c1"># Using the function to write the dictionary to an XML file</span>
            <span class="n">xml_data</span> <span class="o">=</span><span class="n">dict_to_xml</span><span class="p">(</span><span class="n">dic_data</span><span class="p">)</span>
            <span class="n">xml_data_str</span> <span class="o">=</span> <span class="n">xml_data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>
            
            <span class="c1"># Saving the XML to a file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">xml_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span> <span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">xml_data_str</span><span class="p">)</span>
            
            <span class="c1"># Create an XML with x, y values</span>
            <span class="c1"># metadata = ET.Element(&quot;Metadata&quot;)</span>
            <span class="c1"># ref_point_elem = ET.SubElement(metadata, &quot;ReferencePoint&quot;)</span>
            <span class="c1"># x_elem = ET.SubElement(ref_point_elem, &quot;x&quot;)</span>
            <span class="c1"># x_elem.text = str(x)</span>
            <span class="c1"># y_elem = ET.SubElement(ref_point_elem, &quot;y&quot;)</span>
            <span class="c1"># y_elem.text = str(y)</span>
            <span class="c1"># Creating the XML structure</span>
            <span class="c1"># metadata = ET.Element(&quot;Metadata&quot;)</span>
            <span class="c1"># ref_point_elem = ET.SubElement(metadata, &quot;ReferencePoint&quot;)</span>
            <span class="c1"># x_elem = ET.SubElement(ref_point_elem, &quot;x&quot;)</span>
            <span class="c1"># #x_elem.text = str(x)</span>
            <span class="c1"># x_elem.set(&#39;value&#39;, str(x))  # Setting the &#39;value&#39; attribute</span>
            <span class="c1"># y_elem = ET.SubElement(ref_point_elem, &quot;y&quot;)</span>
            <span class="c1"># #y_elem.text = str(y)</span>
            <span class="c1"># y_elem.set(&#39;value&#39;, str(y))  # Setting the &#39;value&#39; attribute</span>

            
            <span class="c1"># # Write the XML to a file</span>
            <span class="c1"># tree = ET.ElementTree(metadata)</span>
            <span class="c1"># tree.write(updated_shapefile_path + &quot;.xml&quot;)</span>
            
            <span class="c1"># with open(shapefile_path + &quot;.xml&quot;, &quot;wb&quot;) as file:</span>
            <span class="c1">#     tree.write(file, encoding=&#39;utf-8&#39;, xml_declaration=True)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ReferencePoint x, y: </span><span class="si">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s1">, VEL, VEL_STD: </span><span class="si">{</span><span class="w"> </span><span class="n">VEL_ref</span><span class="p">,</span><span class="w"> </span><span class="n">VEL_ref_STD</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="n">update_dir_shapefile</span><span class="o">=</span><span class="n">updated_shapefile_path</span>
   
    
    
    <span class="c1"># with open(updated_shapefile_path[:-4] + &quot;.cpg&quot;, &quot;w&quot;) as f:</span>
    <span class="c1">#     f.write(&quot;UTF-8&quot;)</span>
    <span class="k">return</span> <span class="n">gdf</span> <span class="p">,</span> <span class="n">update_dir_shapefile</span></div>


<span class="c1">##################################################################################################</span>


<div class="viewcode-block" id="merge_geodataframes_generator">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.merge_geodataframes_generator">[docs]</a>
<span class="k">def</span> <span class="nf">merge_geodataframes_generator</span><span class="p">(</span><span class="n">gdfs</span><span class="p">):</span>
    <span class="n">total_gdfs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdfs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gdfs</span><span class="p">):</span>
        <span class="c1"># Extracting x, y coordinates from the geometry on-the-fly without adding to the dataframe</span>
        <span class="c1"># xy = gdf.geometry.apply(lambda geom: (geom.x, geom.y))</span>
        <span class="c1"># gdf[&#39;x&#39;], gdf[&#39;y&#39;] = zip(*xy)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># Drop the &#39;geometry&#39; column</span>
        <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

        <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Merging GeoDataFrame </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">total_gdfs</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">yield</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">description</span></div>




    <span class="c1"># Correcting the date format in column names and filtering columns</span>
<span class="k">def</span> <span class="nf">correct_date_format</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">):</span>
        <span class="n">date_part</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if the date part is in valid date format</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_part</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">col</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If not, return None to indicate an invalid date format</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return non-date columns as is</span>
        <span class="k">return</span> <span class="n">col</span>


<div class="viewcode-block" id="merge_geodataframes">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.merge_geodataframes">[docs]</a>
<span class="k">def</span> <span class="nf">merge_geodataframes</span><span class="p">(</span><span class="n">gdfs</span><span class="p">):</span>
    <span class="c1">############3</span>
    
    <span class="c1">################</span>
    <span class="n">gdf_gen</span> <span class="o">=</span> <span class="n">merge_geodataframes_generator</span><span class="p">(</span><span class="n">gdfs</span><span class="p">)</span>
    
    <span class="c1"># Instead of merging iteratively, collect all dataframes and concatenate at once</span>
    <span class="n">dfs_to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">gdf</span> <span class="k">for</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">gdf_gen</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">gdfs</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Preparing GeoDataFrames&quot;</span><span class="p">)]</span>

    <span class="c1"># Concatenate all dataframes</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs_to_merge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Drop duplicates based on x, y</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

    <span class="c1"># Create the final GeoDataFrame with one geometry column</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
    <span class="n">final_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">final_gdf</span></div>



<span class="c1">###################################################################</span>



<div class="viewcode-block" id="mask_raster">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.mask_raster">[docs]</a>
<span class="k">def</span> <span class="nf">mask_raster</span><span class="p">(</span><span class="n">dem_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">no_data_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scatter_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        - Mask a given raster (DEM) array using a binary mask and optionally filter scatter plot data based on the same mask.</span>
<span class="sd">        - dem_array (np.ndarray, optional): The 2D or 3D input raster array to be masked. If 3D, the last dimension is assumed to be the channel dimension (e.g., RGB).</span>
<span class="sd">        - mask_path (str): The path to the raster file containing the binary mask. Values of 1 in the mask represent areas to keep, and values of 0 represent areas to mask out.</span>
<span class="sd">        - no_data_value (scalar, optional): The value to replace the masked regions with in the `dem_array`. Defaults to np.nan.</span>
<span class="sd">        - scatter_x (np.ndarray, optional): The x-coordinates of scatter plot data to be filtered based on the mask. If provided, `scatter_y` must also be provided.</span>
<span class="sd">        - scatter_y (np.ndarray, optional): The y-coordinates of scatter plot data to be filtered based on the mask. If provided, `scatter_x` must also be provided.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        - np.ndarray: The masked raster array. This array will be of the same shape and data type as the input `dem_array`.</span>
<span class="sd">        - (If scatter_x and scatter_y are provided)</span>
<span class="sd">        - np.ndarray: The x-coordinates of the scatter plot data after filtering with the mask.</span>
<span class="sd">        - np.ndarray: The y-coordinates of the scatter plot data after filtering with the mask.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the `dem_array` data type is integer and the `no_data_value` is np.nan, the function will </span>
<span class="sd">        replace NaN values with a default &quot;no data&quot; integer value (-9999) before casting back to the </span>
<span class="sd">        original data type.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">zoom</span>

    <span class="c1"># Read the binary mask</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mask_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mask_src</span><span class="p">:</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">mask_src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># If the shapes don&#39;t match and dem_array is provided, resize mask_array</span>
    <span class="k">if</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">y_scale</span> <span class="o">=</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_scale</span> <span class="o">=</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">mask_array</span><span class="p">,</span> <span class="p">(</span><span class="n">y_scale</span><span class="p">,</span> <span class="n">x_scale</span><span class="p">))</span>

    <span class="c1">#################3Threshold mask_array</span>
    <span class="n">mask_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_array</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Check if scatter_x and scatter_y are provided</span>
    <span class="n">scatter_x_masked</span><span class="p">,</span> <span class="n">scatter_y_masked</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">scatter_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scatter_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scatter_x</span><span class="p">)</span>
        <span class="n">scatter_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scatter_y</span><span class="p">)</span>
        <span class="c1"># Ensure scatter coordinates are within the bounds of the mask_array</span>
        <span class="n">scatter_x_clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">scatter_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">scatter_y_clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">scatter_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">mask_array</span><span class="p">[</span><span class="n">scatter_y_clipped</span><span class="p">,</span> <span class="n">scatter_x_clipped</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">scatter_x_masked</span> <span class="o">=</span> <span class="n">scatter_x</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="n">scatter_y_masked</span> <span class="o">=</span> <span class="n">scatter_y</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

    <span class="c1"># If dem_array is provided, mask it</span>
    <span class="n">masked_array</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_array</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dem_array</span><span class="p">,</span> <span class="n">no_data_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dem_array</span><span class="p">,</span> <span class="n">no_data_value</span><span class="p">)</span>

        <span class="c1"># Handle casting to original data type</span>
        <span class="n">original_dtype</span> <span class="o">=</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">original_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">int_no_data</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">masked_array</span><span class="p">),</span> <span class="n">int_no_data</span><span class="p">,</span> <span class="n">masked_array</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">original_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">masked_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">original_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scatter_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scatter_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">,</span> <span class="n">scatter_x_masked</span><span class="p">,</span> <span class="n">scatter_y_masked</span>
    <span class="k">elif</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scatter_x_masked</span><span class="p">,</span> <span class="n">scatter_y_masked</span></div>



<span class="c1"># Correcting the date format in column names and filtering columns</span>
<div class="viewcode-block" id="correct_date_format">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.correct_date_format">[docs]</a>
<span class="k">def</span> <span class="nf">correct_date_format</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">):</span>
        <span class="n">date_part</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if the date part is in valid date format</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_part</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">col</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If not, return None to indicate an invalid date format</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return non-date columns as is</span>
        <span class="k">return</span> <span class="n">col</span></div>


<div class="viewcode-block" id="Optical_flow_akhdefo">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.Optical_flow_akhdefo">[docs]</a>
<span class="k">def</span> <span class="nf">Optical_flow_akhdefo</span><span class="p">(</span><span class="n">input_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">AOI</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="mi">2</span> <span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">image_resolution</span><span class="o">=</span><span class="s1">&#39;3125mm&#39;</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">point_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                          <span class="n">dem_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                            <span class="n">good_match_option</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shapefile_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_triplet_interval</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
                            <span class="n">pixel_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="mi">0</span> <span class="p">,</span> <span class="n">pyr_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                            <span class="n">master_reference</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="n">selection_Mode</span><span class="o">=</span><span class="s1">&#39;triplet&#39;</span> <span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">krig_method</span><span class="o">=</span><span class="s1">&#39;ordinary&#39;</span><span class="p">,</span> <span class="n">spatial_ref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_detrend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                            <span class="n">use_zscore_krig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbit_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dense_match_option</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">   </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs feature matching and velocity/displacement calculations across a series of images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_dir: str</span>
<span class="sd">        Path to the directory where the input images are stored.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Path to the directory where the output files will be saved.</span>

<span class="sd">    AOI : str</span>
<span class="sd">        The shapefile that represents the Area of Interest (AOI).</span>

<span class="sd">    zscore_threshold : float</span>
<span class="sd">        The threshold value used to filter matches based on their Z-score.</span>

<span class="sd">    image_resolution : str</span>
<span class="sd">        The resolution of the images specified per pixel. This can be expressed in various units </span>
<span class="sd">        like &#39;3125mm&#39;, &#39;3.125m&#39; or &#39;3.125meter&#39;.</span>

<span class="sd">    VEL_scale: (str, optional)</span>
<span class="sd">        options year, month, None , default year</span>
<span class="sd">    </span>
<span class="sd">    VEL_Mode: str</span>
<span class="sd">        Options linear or mean , default linear</span>

<span class="sd">    good_match_option: float</span>
<span class="sd">        ratio test as per Lowe&#39;s paper default 0.75</span>

<span class="sd">    shapefile_output: bool</span>
<span class="sd">        True to export timeseries as deformation products as shapefile, default False</span>
<span class="sd">    </span>
<span class="sd">    max_triplet_interval: int </span>
<span class="sd">        Maximum interval days between images allowed to form triplets</span>
<span class="sd">        </span>
<span class="sd">    master_reference: str </span>
<span class="sd">        single, multiple, None</span>
<span class="sd">        </span>
<span class="sd">    Vegetation_mask: (str, optional)</span>
<span class="sd">        Path to a raster file that represents a vegetation mask. Pixels in the input image</span>
<span class="sd">        that correspond to non-vegetation in the mask will be set to one.</span>
<span class="sd">    </span>
<span class="sd">    pyr_scale: float</span>
<span class="sd">        parameter, specifying the image scale (&lt;1) to build pyramids for each image; pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.</span>
<span class="sd">    levels: int</span>
<span class="sd">        number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used.</span>
<span class="sd">    winsize: int</span>
<span class="sd">        averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field.</span>
<span class="sd">    iterations: int</span>
<span class="sd">        number of iterations the algorithm does at each pyramid level.</span>
<span class="sd">    poly_n: int</span>
<span class="sd">        size of the pixel neighborhood used to find polynomial expansion in each pixel; </span>
<span class="sd">        larger values mean that the image will be approximated with smoother surfaces, </span>
<span class="sd">        yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7.</span>
<span class="sd">        </span>
<span class="sd">    poly_sigma: float</span>
<span class="sd">        standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; </span>
<span class="sd">        for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a good value would be poly_sigma=1.5.</span>
<span class="sd">    flags: 0 or 1</span>
<span class="sd">        operation flags that can be a combination of the following:</span>
<span class="sd">        0 OPTFLOW_USE_INITIAL_FLOW uses the input flow as an initial flow approximation.</span>
<span class="sd">        1 OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian winsizewinsize filter instead of a box filter of the same size for optical flow estimation; </span>
<span class="sd">        usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; </span>
<span class="sd">        normally, winsize for a Gaussian window should be set to a larger value to achieve the same level of robustness.</span>
<span class="sd">    </span>
<span class="sd">    start_date: str (example 20210203)</span>
<span class="sd">        The start date of the image series.</span>

<span class="sd">    end_date: str (example 20210503)</span>
<span class="sd">        The end date of the image series. </span>
<span class="sd">        </span>
<span class="sd">    krig_method: str &#39;ordinary&#39; , &#39;simple&#39; , &#39;universal&#39;</span>
<span class="sd">        selection of kriging interpolation method, the workflow is based on gstools library. default is &#39;ordinary&#39;  </span>
<span class="sd">    </span>
<span class="sd">    use_zscore_krig: float </span>
<span class="sd">        default is None use this option to maintain interpolation within min max limit of data</span>
<span class="sd">        </span>
<span class="sd">    orbit_dir: str None, &#39;asc&#39; , &#39;desc&#39; , &#39;NS&#39; , &#39;EW&#39;</span>
<span class="sd">        if optical image set orbit_dir=None , &#39;EW&#39; or &#39;NS&#39; based on slope face of area of interest, if Radar image set orbit_dir to &#39;asc&#39; or &#39;desc&#39;</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image1 : numpy.ndarray</span>
<span class="sd">        The first image in the series.</span>

<span class="sd">    image3 : numpy.ndarray</span>
<span class="sd">        The third image in the series.</span>

<span class="sd">    mean_vel_list : list</span>
<span class="sd">        A list of mean velocity arrays, each array corresponding to a pair of images.</span>

<span class="sd">    mean_flowx_list : list</span>
<span class="sd">        A list of mean x-flow arrays, each array corresponding to a pair of images.</span>

<span class="sd">    mean_flowy_list : list</span>
<span class="sd">        A list of mean y-flow arrays, each array corresponding to a pair of images.</span>

<span class="sd">    points1_i : numpy.ndarray</span>
<span class="sd">        Array of keypoints for the first image in the last pair.</span>

<span class="sd">    points2 : numpy.ndarray</span>
<span class="sd">        Array of keypoints for the second image in the last pair.</span>
<span class="sd">        </span>
<span class="sd">        </span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">detect_keypoints</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
        <span class="n">sift</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">SIFT_create</span><span class="p">()</span>
        <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span> <span class="o">=</span> <span class="n">sift</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span>


    <span class="k">def</span> <span class="nf">compare_images</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">):</span>
        <span class="c1"># Rasterio reads data as (bands, height, width)</span>
        <span class="c1"># OpenCV expects data as (height, width, channels)</span>
        <span class="c1"># So we need to transpose the data</span>
        <span class="c1"># image1 = np.transpose(image1, [1, 2, 0])</span>
        <span class="c1"># image2 = np.transpose(image2, [1, 2, 0])</span>
        <span class="c1"># Convert the images to grayscale</span>
        <span class="k">if</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">image1</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">image2</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="c1"># image1_gray = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)</span>
        <span class="c1"># image2_gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)</span>
        <span class="c1"># Calculate SSIM</span>
       
        <span class="n">mask1</span><span class="o">=</span><span class="n">gray1</span><span class="p">[</span><span class="n">gray1</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">mask2</span><span class="o">=</span><span class="n">gray2</span><span class="p">[</span><span class="n">gray2</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">ssim_index</span><span class="p">,</span> <span class="n">ssim_map</span> <span class="o">=</span> <span class="n">ssim</span><span class="p">(</span><span class="n">gray1</span><span class="p">,</span> <span class="n">gray2</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ssim_map</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">ssim_map</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">ssim_map</span><span class="p">[</span><span class="n">ssim_map</span><span class="o">&gt;</span><span class="mf">0.95</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># Compute the structural similarity index (SSIM) between the two images</span>
        <span class="k">return</span> <span class="n">ssim_map</span>


    <span class="c1">####### This section is used for dense matching####################</span>
    <span class="k">def</span> <span class="nf">is_valid_pixel</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if a pixel at (x, y) is valid (not zero and not NaN).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">create_dense_keypoints_for_valid_pixels</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a dense grid of keypoints across the image, excluding invalid pixels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keypoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step_size</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">step_size</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">is_valid_pixel</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                    <span class="n">keypoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">KeyPoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">keypoints</span>

    <span class="k">def</span> <span class="nf">extract_descriptors</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">patch_size</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract descriptors for the keypoints by using image patches.</span>
<span class="sd">        :param image: The input image.</span>
<span class="sd">        :param keypoints: List of keypoints.</span>
<span class="sd">        :param patch_size: The size of the patch to extract around each keypoint.</span>
<span class="sd">        :return: Numpy array of descriptors.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">half_size</span> <span class="o">=</span> <span class="n">patch_size</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">for</span> <span class="n">kp</span> <span class="ow">in</span> <span class="n">keypoints</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kp</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">kp</span><span class="o">.</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">-</span> <span class="n">half_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">-</span> <span class="n">half_size</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">+</span> <span class="n">half_size</span> <span class="o">&gt;</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">+</span> <span class="n">half_size</span> <span class="o">&gt;</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">continue</span>  <span class="c1"># Skip keypoints near the border</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">image</span><span class="p">[</span><span class="n">y</span><span class="o">-</span><span class="n">half_size</span><span class="p">:</span><span class="n">y</span><span class="o">+</span><span class="n">half_size</span><span class="p">,</span> <span class="n">x</span><span class="o">-</span><span class="n">half_size</span><span class="p">:</span><span class="n">x</span><span class="o">+</span><span class="n">half_size</span><span class="p">]</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">descriptors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">correlate_descriptors</span><span class="p">(</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors2</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Correlate descriptors between two sets and return matches.</span>
<span class="sd">        :param descriptors1: Descriptors from the first image.</span>
<span class="sd">        :param descriptors2: Descriptors from the second image.</span>
<span class="sd">        :return: List of DMatch objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Use a simple nearest-neighbor approach for matching</span>
        <span class="c1"># This is a placeholder for more sophisticated matching methods</span>
        <span class="n">bf</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BFMatcher</span><span class="p">(</span><span class="n">cv2</span><span class="o">.</span><span class="n">NORM_L2</span><span class="p">,</span> <span class="n">crossCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors2</span><span class="p">)</span>
        <span class="c1">#matches = bf.knnMatch(descriptors1, descriptors2, k=2)</span>
        <span class="k">return</span> <span class="n">matches</span>
    <span class="k">def</span> <span class="nf">filter_matches_by_stability</span><span class="p">(</span><span class="n">matches</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">75</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter matches based on a distance threshold for stability.</span>
<span class="sd">        :param matches: List of DMatch objects.</span>
<span class="sd">        :param threshold: Distance threshold for filtering.</span>
<span class="sd">        :return: Filtered list of DMatch objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span>
        <span class="n">filtered_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">filtered_matches</span>
   
    
    
    <span class="c1">######################################################################</span>

    <span class="k">def</span> <span class="nf">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">descriptor1</span><span class="p">,</span> <span class="n">descriptor2</span><span class="p">,</span> <span class="n">keypoint1</span><span class="p">,</span> <span class="n">keypoint2</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">,</span> <span class="n">dense_match_option</span><span class="o">=</span><span class="n">dense_match_option</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">dense_match_option</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">good_matches</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Initialize an empty list for good_matches</span>
            <span class="n">bf</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BFMatcher</span><span class="p">(</span><span class="n">crossCheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">knnMatch</span><span class="p">(</span><span class="n">descriptor1</span><span class="p">,</span> <span class="n">descriptor2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># Calculate distances for all matches</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span>
            <span class="c1"># Calculate mean and standard deviation of distances</span>
            <span class="n">mean_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">std_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="c1"># Define a threshold based on the Z-score</span>
            <span class="n">z_score_threshold</span> <span class="o">=</span> <span class="n">zscore_threshold</span>
            <span class="c1">#mean_distance + z_score_threshold * std_distance</span>
            <span class="c1"># Filter matches based on the Z-score</span>
            <span class="k">if</span> <span class="n">good_match_option</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">good_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">good_match_option</span> <span class="o">*</span> <span class="n">n</span><span class="o">.</span><span class="n">distance</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">good_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">mean_distance</span> <span class="o">+</span> <span class="n">z_score_threshold</span> <span class="o">*</span> <span class="n">std_distance</span><span class="p">]</span>
            
        <span class="k">elif</span> <span class="n">dense_match_option</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            
            <span class="c1"># Create dense keypoints for both images</span>
            <span class="n">keypoint1</span> <span class="o">=</span> <span class="n">create_dense_keypoints_for_valid_pixels</span><span class="p">(</span><span class="n">image1</span><span class="p">)</span>
            <span class="n">keypoint2</span> <span class="o">=</span> <span class="n">create_dense_keypoints_for_valid_pixels</span><span class="p">(</span><span class="n">image2</span><span class="p">)</span>

            <span class="c1"># Extract descriptors from both images</span>
            <span class="n">descriptor1</span> <span class="o">=</span> <span class="n">extract_descriptors</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">keypoint1</span><span class="p">)</span>
            <span class="n">descriptor2</span> <span class="o">=</span> <span class="n">extract_descriptors</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="n">keypoint2</span><span class="p">)</span>

            <span class="c1"># Correlate descriptors</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="n">correlate_descriptors</span><span class="p">(</span><span class="n">descriptor1</span><span class="p">,</span> <span class="n">descriptor2</span><span class="p">)</span>
           
           <span class="c1"># Filter matches based on stability</span>
            <span class="n">good_matches</span> <span class="o">=</span> <span class="n">matches</span>
            

        <span class="n">descriptor12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">descriptor1</span><span class="p">,</span> <span class="n">descriptor2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">keypoint12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">keypoint1</span><span class="p">,</span> <span class="n">keypoint2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


        <span class="c1"># # Filter the keypoints</span>
        <span class="c1"># keypoint12 = [keypoint12[m.queryIdx] for m in good_matches]</span>
        <span class="c1"># # Filter the descriptors</span>
        <span class="c1"># descriptor12 = np.array([descriptor12[m.queryIdx] for m in good_matches])</span>
            
        
        
       
        <span class="k">return</span> <span class="n">good_matches</span><span class="p">,</span> <span class="n">descriptor12</span><span class="p">,</span> <span class="n">keypoint12</span>
        

   

    <span class="k">def</span> <span class="nf">calculate_optical_flow</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">,</span> <span class="n">pyr_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orbit_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Rasterio reads data as (bands, height, width)</span>
        <span class="c1"># OpenCV expects data as (height, width, channels)</span>
        <span class="c1"># So we need to transpose the data</span>
        <span class="c1"># image1 = np.transpose(image1, [1, 2, 0])</span>
        <span class="c1"># image2 = np.transpose(image2, [1, 2, 0])</span>
        
        <span class="c1"># Convert the images to grayscale</span>

        <span class="k">if</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">image1</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">image2</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="c1"># Confirm that gray1 and gray2 are both 2D (grayscale) images of the same size</span>
        <span class="k">assert</span> <span class="n">gray1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;gray1 is not a grayscale image&quot;</span>
        <span class="k">assert</span> <span class="n">gray2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;gray2 is not a grayscale image&quot;</span>
        <span class="k">assert</span> <span class="n">gray1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">gray2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;gray1 and gray2 are not the same size&quot;</span>
        
        <span class="c1"># Calculate optical flow</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcOpticalFlowFarneback</span><span class="p">(</span><span class="n">gray1</span><span class="p">,</span> <span class="n">gray2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span><span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>

        <span class="n">ssim</span><span class="o">=</span><span class="n">compare_images</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">)</span>
    

        <span class="n">flowx</span><span class="o">=</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">flowy</span><span class="o">=</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="n">flowx</span><span class="p">[</span><span class="n">ssim</span> <span class="o">&lt;</span><span class="n">ssim_thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flowy</span><span class="p">[</span><span class="n">ssim</span> <span class="o">&lt;</span><span class="n">ssim_thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Compute the magnitude and angle of the 2D vectors</span>
        <span class="n">magnitude</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cartToPolar</span><span class="p">(</span><span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">)</span>
        <span class="c1">#magnitude = np.sqrt(flowx**2 + flowy**2)</span>
        
        

        <span class="c1"># Compute z-scores for the x_flow</span>
        <span class="n">z_scores_x</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Compute z-scores for the y_flow</span>
        <span class="n">z_scores_y</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        
        <span class="c1"># Create a mask for vectors with a z-score less than the threshold</span>
        <span class="n">mask_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_scores_y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zscore_threshold</span>
        <span class="n">mask_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_scores_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zscore_threshold</span>
        
        <span class="c1"># Zero out the vectors where the mask is False</span>
        <span class="n">flowx</span><span class="p">[</span><span class="o">~</span><span class="n">mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flowy</span><span class="p">[</span><span class="o">~</span><span class="n">mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">flowx</span><span class="p">[</span><span class="o">~</span><span class="n">mask_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flowy</span><span class="p">[</span><span class="o">~</span><span class="n">mask_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        
        
        <span class="n">magnitude</span><span class="p">[</span><span class="o">~</span><span class="n">mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">magnitude</span><span class="p">[</span><span class="o">~</span><span class="n">mask_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="n">orbit_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orbit_dir</span><span class="o">==</span><span class="s1">&#39;asc&#39;</span><span class="p">:</span>
                
                
                <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">flowx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowy</span><span class="p">)),</span> <span class="o">-</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">)</span>
                
            <span class="k">elif</span> <span class="n">orbit_dir</span><span class="o">==</span><span class="s1">&#39;desc&#39;</span><span class="p">:</span>
                <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">flowx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowy</span><span class="p">)),</span> <span class="n">magnitude</span><span class="p">,</span> <span class="o">-</span><span class="n">magnitude</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="n">orbit_dir</span> <span class="o">==</span><span class="s1">&#39;EW&#39;</span><span class="p">:</span>
                <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">flowx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowy</span><span class="p">)),</span> <span class="n">magnitude</span><span class="p">,</span> <span class="o">-</span><span class="n">magnitude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbit_dir</span> <span class="o">==</span><span class="s1">&#39;NS&#39;</span><span class="p">:</span>
                <span class="n">magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">flowy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowx</span><span class="p">)),</span> <span class="o">-</span><span class="n">magnitude</span><span class="p">,</span> <span class="n">magnitude</span><span class="p">)</span>
            
        <span class="c1"># Post-process magnitude to make it negative when flowx is negative</span>
        <span class="c1">#magnitude = np.where(flowx &lt; 0, -magnitude, magnitude)</span>
       
        <span class="k">return</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">ssim</span>

    <span class="k">def</span> <span class="nf">filter_velocity</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">good_matches</span><span class="p">,</span> <span class="n">keypoints1</span><span class="p">,</span> <span class="n">keypoints2</span><span class="p">):</span>
        <span class="n">points1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">keypoints1</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">queryIdx</span><span class="p">]</span><span class="o">.</span><span class="n">pt</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">good_matches</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">points2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">keypoints2</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">trainIdx</span><span class="p">]</span><span class="o">.</span><span class="n">pt</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">good_matches</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points1</span><span class="p">)):</span>
            <span class="n">velocity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">velocity</span><span class="p">),</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span>

    <span class="k">def</span> <span class="nf">calculate_velocity_displacement</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time interval must not be zero.&quot;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
            <span class="n">nframes</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
            <span class="n">nframes</span><span class="o">=</span><span class="mi">3</span>
        <span class="n">velocity</span><span class="o">=</span> <span class="n">velocity</span><span class="o">/</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="o">/</span><span class="n">time_interval</span>
        
        <span class="n">flowx</span> <span class="o">=</span> <span class="n">flowx</span><span class="o">/</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="o">/</span><span class="n">time_interval</span>
        
        <span class="n">flowy</span> <span class="o">=</span> <span class="n">flowy</span><span class="o">/</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="o">/</span><span class="n">time_interval</span>
        
        
        

        <span class="k">return</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span>


    
    

    <span class="k">def</span> <span class="nf">separate_floats_letters</span><span class="p">(</span><span class="n">input_string</span><span class="p">):</span>
        <span class="n">floats</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+\.\d+|\d+&#39;</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-zA-Z]+&#39;</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">letters</span><span class="p">,</span> <span class="n">floats</span>

    <span class="n">input_string</span> <span class="o">=</span> <span class="n">image_resolution</span>
    <span class="n">unit</span><span class="p">,</span> <span class="n">img_res</span> <span class="o">=</span> <span class="n">separate_floats_letters</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span>

    

    <span class="k">def</span> <span class="nf">calculate_hillshade</span><span class="p">(</span><span class="n">dem_file_path</span><span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Open the raster data</span>

        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dem_file_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">dem_src</span><span class="p">:</span>
            <span class="n">dem</span> <span class="o">=</span> <span class="n">dem_src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate hillshade from the DEM</span>
        <span class="k">if</span> <span class="n">hillshade_option</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">hillshade</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">hillshade</span><span class="p">(</span><span class="n">dem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hillshade</span><span class="o">=</span><span class="n">dem</span>
        <span class="k">return</span> <span class="n">hillshade</span>

    
    
    
    
    
    <span class="k">def</span> <span class="nf">get_values_from_xml</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Parse the XML file</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

            <span class="c1"># Extracting x and y coordinates</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;ReferencePoint/Coordinates&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Parsing the coordinate string</span>
                <span class="n">coordinates_text</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="c1"># Assuming the format is &quot;(x, y)&quot;</span>
                <span class="n">coordinates_text</span> <span class="o">=</span> <span class="n">coordinates_text</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;() &quot;</span><span class="p">)</span>
                <span class="n">x_str</span><span class="p">,</span> <span class="n">y_str</span> <span class="o">=</span> <span class="n">coordinates_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_str</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># Extracting VEL and VEL_STD</span>
            <span class="n">veld_data</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VELDATA&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">veld_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vel</span> <span class="o">=</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">vel_std</span> <span class="o">=</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vel</span><span class="p">,</span> <span class="n">vel_std</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># Convert to float if not None</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">vel</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span> <span class="k">if</span> <span class="n">vel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">vel_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vel_std</span><span class="p">)</span> <span class="k">if</span> <span class="n">vel_std</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">vel_std</span>

        <span class="k">except</span> <span class="n">ET</span><span class="o">.</span><span class="n">ParseError</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;XML Parse Error: </span><span class="si">{</span><span class="n">pe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    
    
    <span class="k">def</span> <span class="nf">plot_reference_point</span><span class="p">(</span><span class="n">xml_file_path</span><span class="p">,</span> <span class="n">list_figures</span><span class="o">=</span><span class="p">[],</span> <span class="n">figure_paths</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts x, y coordinates from the given XML file and plots them on the provided axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            - xml_file_path (str): Path to the XML file containing the reference point data.</span>
<span class="sd">            - ax (matplotlib.axes.Axes, optional): Axes on which to plot. If None, a new figure and axes will be created.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - matplotlib.axes.Axes: The axes on which the data was plotted.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xml_file_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">vel_std</span> <span class="o">=</span> <span class="n">get_values_from_xml</span><span class="p">(</span><span class="n">xml_file_path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_figures</span><span class="p">):</span>
                <span class="c1">#print(&quot;x, y&quot;, x, y)</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axs</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
                    <span class="c1"># We will annotate the point (x=5, y=sin(5))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;REF&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="c1"># 4. Save each figure to a PNG file</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_figures</span><span class="p">):</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figure_paths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferencePoint x or y not found in the provided XML file.&quot;</span><span class="p">)</span>

        
       


    

    <span class="k">def</span> <span class="nf">plot_velocity_displacement</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">date1</span><span class="p">,</span> <span class="n">date2</span><span class="p">,</span> <span class="n">pdf_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">time_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span>
                                     <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">dem_file</span><span class="o">=</span><span class="n">dem_path</span><span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="n">hillshade_option</span><span class="p">):</span>
        
        
        <span class="k">if</span> <span class="n">hillshade_option</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            
            <span class="n">hillshade</span><span class="o">=</span><span class="n">calculate_hillshade</span><span class="p">(</span><span class="n">dem_file</span> <span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="n">hillshade_option</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">hillshade_option</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="c1"># if len(image1.shape) == 2:  # It&#39;s already grayscale</span>
            <span class="c1">#     gray=image1</span>
                
            <span class="c1"># elif len(image1.shape) == 3 and image1.shape[2] == 3:  # It&#39;s RGB</span>
            <span class="c1">#     # Convert RGB to grayscale using the weighted method</span>
            <span class="c1">#     gray = 0.299 * image1[:, :, 0] + 0.587 * image1[:, :, 1] + 0.114 * image1[:, :, 2]</span>
            <span class="c1">#     gray=gray.astype(np.uint8)</span>
            
            <span class="c1"># hillshade=calculate_hillshade(gray , hillshade_option=hillshade_option)</span>
            <span class="n">hillshade</span><span class="o">=</span><span class="n">image1</span>
                
           
            

        <span class="c1">#image1=image1.transpose([1, 2, 0])  </span>
        <span class="c1"># image size in pixels</span>
        <span class="n">image_width</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">image_height</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># image bounds in geographic coordinates</span>
        <span class="n">geo_bounds</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">}</span>


        <span class="n">pixels</span> <span class="o">=</span> <span class="n">points1</span>
        
            
        <span class="c1"># convert pixel coordinates to geographic coordinates</span>
        <span class="n">geo_coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">image_width</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]),</span>
                    <span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">image_height</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">]</span>

        <span class="c1"># separate the coordinates for plotting</span>
        <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">geo_coords</span><span class="p">)</span>

      
        <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
            
            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vmin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Data has negative values, use TwoSlopeNorm</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">mcolors</span><span class="o">.</span><span class="n">TwoSlopeNorm</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vcenter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;rainbow&#39;</span>
                <span class="k">return</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Data has no negative values, use standard normalization</span>
                <span class="n">norm</span><span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
                
                <span class="k">return</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span>

        
        
        
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Plot flowx</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[0, 0], title=f&#39;Disp-X({unit}) - {date1} to {date2}&#39;, extent=bounds)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowx</span><span class="p">))</span>
        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">flowx</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">minmax</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">minmax</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>

        <span class="n">flowx_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">flowx</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
       
        <span class="c1"># Create colorbar for flowx</span>
        <span class="n">flowx_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">flowx_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">flowx_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Disp-X(</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s1">) - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Plot flowy</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[0, 1], extent=bounds, title=f&#39;Disp-Y({unit}) - {date1} to {date2}&#39;)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowy</span><span class="p">))</span>
        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">flowy</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">minmax</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">minmax</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>
        <span class="n">flowy_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">flowy</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Disp-Y(</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s1">) - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Create colorbar for flowy</span>
        <span class="n">flowy_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">flowy_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">flowy_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Plot Velocity Magnitude</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[1, 0], extent=bounds, title=f&#39;Velocity - {date1} to {date2}&#39;)</span>
        
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">velocity</span><span class="p">))</span>
        <span class="n">min_v</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>

        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">min_v</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">minmax</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>
        <span class="n">velocity_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">velocity</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>  <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Velocity - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Create colorbar for velocity</span>
        <span class="n">velocity_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">velocity_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">velocity_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">time_interval</span><span class="p">)</span><span class="si">}</span><span class="s1">days&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Plot Velocity Direction</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[1, 1], extent=bounds, title=f&#39;Velocity Direction - {date1} to {date2}&#39;)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">velocity_direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">360</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">flowy</span><span class="p">,</span> <span class="n">flowx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        
        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">velocity_direction</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmocean</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">phase</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">360</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>
        <span class="n">velocity_direction_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">velocity_direction</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Velocity Direction - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Create colorbar for velocity direction</span>
        <span class="n">velocity_direction_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">velocity_direction_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">velocity_direction_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        

        <span class="c1"># Set the extent of the axes</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        
        
        <span class="c1"># Automatically adjust subplot parameters for a tight layout</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pdf_filename</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">pdf_filename</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">show_figure</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


    
        <span class="n">flowx_scatter</span><span class="o">=</span><span class="n">flowx_scatter</span><span class="o">.</span><span class="n">get_offsets</span><span class="p">()</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">flowx_scatter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">flowx_scatter</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        

        <span class="k">return</span>  <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="p">,</span> <span class="n">pixels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_date_from_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Searching for a date in the format &#39;YYYY-MM-DD&#39; or &#39;YYYYMMDD&#39;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d</span><span class="si">{4}</span><span class="s1">-\d</span><span class="si">{2}</span><span class="s1">-\d</span><span class="si">{2}</span><span class="s1">)|(\d</span><span class="si">{8}</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">date_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
                <span class="c1"># Determine the date format</span>
                <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="s1">&#39;-&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">date_str</span> <span class="k">else</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span>
                <span class="c1"># Parse the date string</span>
                <span class="n">date_obj</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">date_obj</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No date string found in filename.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Date string &#39;</span><span class="si">{</span><span class="n">date_str</span><span class="si">}</span><span class="s2">&#39; in filename is not in expected format.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>



    <span class="k">def</span> <span class="nf">mean_of_arrays</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">):</span>
        <span class="c1"># Determine the size of the larger array</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">array1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">array2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Use np.pad to extend the smaller array with zeros</span>
        <span class="n">array1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">array1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">array2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array2</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">array2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
       <span class="c1"># Compute the mean of the two arrays element-wise</span>
        <span class="n">mean_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        

        <span class="k">return</span> <span class="n">mean_array</span>

    

    

    <span class="k">def</span> <span class="nf">replace_nan_with_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Create a 2D grid of coordinates based on the x, y values</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

            <span class="c1"># Flatten the coordinates grid and build a KDTree</span>
            <span class="n">flattened_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xi</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">flattened_coordinates</span><span class="p">)</span>

            <span class="c1"># Query the tree for nearest neighbors to each point in x, y</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>

            <span class="c1"># Replace NaNs with z values at these indices</span>
            <span class="c1">#zi = np.full_like(xi, np.nan)</span>
            
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        
            <span class="k">return</span> <span class="n">zi</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="k">return</span> <span class="n">zi</span>


    

    

    <span class="k">def</span> <span class="nf">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">reference_raster</span><span class="p">,</span> <span class="n">shapefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="o">=</span><span class="n">Vegetation_mask</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get the CRS, width, height, and transform from the reference raster</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">reference_raster</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">left</span>
                <span class="n">x_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span>
                <span class="n">y_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span>
                <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                

            <span class="c1"># Create a 2D grid of coordinates based on the x, y values</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

            <span class="c1"># Create an array of the same size as the x, y grid filled with NaN</span>
            <span class="c1">#zi = np.full_like(xi, yi, np.nan)</span>
            <span class="c1">#zi = np.zeros_like(xi)</span>

            
                

            <span class="k">if</span> <span class="n">interpolate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Interpolate z values onto the new grid</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Replace interpolated values outside the range with mean of initial z values</span>
                <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&lt;</span> <span class="n">z_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&gt;</span> <span class="n">z_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

                <span class="c1"># Find the indices of interpolated points exceeding the data range</span>
                <span class="n">out_of_range_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">xi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">yi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

                <span class="c1"># Replace out-of-range interpolated points with the mean of valid data points</span>
                <span class="n">zi_valid</span> <span class="o">=</span> <span class="n">zi</span><span class="p">[</span><span class="o">~</span><span class="n">out_of_range_indices</span><span class="p">]</span>
                <span class="n">mean_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">zi_valid</span><span class="p">)</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_of_range_indices</span><span class="p">,</span> <span class="n">mean_valid</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">interpolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zi</span><span class="o">=</span><span class="n">replace_nan_with_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="c1"># # Flatten the coordinates grid and build a KDTree</span>
                <span class="c1"># flattened_coordinates = np.column_stack((xi.ravel(), yi.ravel()))</span>
                <span class="c1"># tree = cKDTree(flattened_coordinates)</span>

                <span class="c1"># # Query the tree for nearest neighbors to each point in x, y</span>
                <span class="c1"># _, indices = tree.query(np.column_stack((x, y)))</span>

                <span class="c1"># # Replace NaNs with z values at these indices</span>
                <span class="c1"># np.put(zi, indices, z)</span>
                

                
            
             <span class="c1"># Apply low-pass filter</span>
            <span class="k">if</span> <span class="n">smoothing_kernel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#zi_initial=zi</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothing_kernel_size</span> <span class="p">)</span>  <span class="c1"># Adjust sigma according to your desired smoothing strength</span>
                <span class="c1">#if interpolate is None:</span>
                    <span class="c1">#zi[zi_initial == 0] = np.nan</span>

            <span class="k">if</span> <span class="n">shapefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Load shapefile, convert it to the correct CRS and get its geometry</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
                <span class="n">shapes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># Generate a mask from the shapes</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">geometry_mask</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">out_shape</span><span class="o">=</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Apply the mask to the interpolated data</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zi</span><span class="o">=</span><span class="n">mask_raster</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">Vegetation_mask</span> <span class="p">)</span>


            <span class="c1"># Define the profile</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
                <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
                <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">zi</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">crs</span><span class="p">,</span>
                <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
                <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># specify the nodata value</span>
            <span class="p">}</span>

            <span class="c1"># Write to a new .tif file</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred while creating the GeoTIFF:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">zi</span>
    
    
    
    <span class="k">def</span> <span class="nf">crop_to_overlap</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

            <span class="c1"># User provided start and end date strings</span>
            <span class="n">start_date</span> <span class="o">=</span> <span class="n">start_date</span>
            <span class="n">end_date</span> <span class="o">=</span> <span class="n">end_date</span>

            <span class="c1"># Converting the strings to datetime objects</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Generating the list of dates</span>
            <span class="n">date_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_date</span> <span class="o">=</span> <span class="n">start</span>
            <span class="k">while</span> <span class="n">current_date</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">date_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span>
                <span class="n">current_date</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
              
        <span class="c1">##############</span>
        
        <span class="n">image_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">))</span>
        
        <span class="c1">##Filter images based on start and end date</span>
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">image_files</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">date_list</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_files</span>
        <span class="c1">#########################</span>
        
        <span class="n">valid_extensions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="s1">&#39;.bmp&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">]</span>
        <span class="n">image_path_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">bound_list</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1"># Calculate mutual overlap</span>
        <span class="n">overlap_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">image_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">valid_extensions</span><span class="p">:</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
                <span class="n">image_path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="n">meta</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">meta</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
                    <span class="n">bound_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
                    <span class="n">image_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">bounds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">overlap_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">overlap_box</span> <span class="o">=</span> <span class="n">image_box</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">overlap_box</span> <span class="o">=</span> <span class="n">overlap_box</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">image_box</span><span class="p">)</span>

        <span class="c1"># Read images and crop to mutual overlap</span>
        <span class="n">cropped_images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">keypoints</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">descriptors</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">image_path</span> <span class="ow">in</span> <span class="n">image_path_list</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">overlap_window</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">overlap_box</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
                <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
                <span class="n">maskNan</span><span class="o">=</span><span class="n">cropped_image</span><span class="p">[</span><span class="n">cropped_image</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">meta</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">meta</span>
                 <span class="c1"># Rasterio reads data as (bands, height, width)</span>
                <span class="c1">#OpenCV expects data as (height, width, channels)</span>
                <span class="c1">#So we need to transpose the data</span>
                <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">cropped_image</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">cropped_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cropped_image</span><span class="p">)</span>
                <span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">detect_keypoints</span><span class="p">(</span><span class="n">cropped_image</span><span class="p">)</span>
                <span class="n">keypoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kp</span><span class="p">)</span>
                <span class="n">descriptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">des</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>     
            <span class="n">filtered_dates</span><span class="o">=</span><span class="n">date_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_dates</span><span class="o">=</span><span class="n">image_files</span>
        <span class="c1">#print(&quot;Cropped {} images.&quot;.format(len(cropped_images)))</span>
        <span class="k">return</span> <span class="n">cropped_images</span><span class="p">,</span> <span class="n">bound_list</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">,</span> <span class="n">image_path_list</span><span class="p">,</span> <span class="n">filtered_dates</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">maskNan</span>


    <span class="c1">##########################################################temp</span>
   
    





<span class="c1">###################################</span>

    
    

    <span class="k">def</span> <span class="nf">feature_matching</span><span class="p">(</span><span class="n">folder_path</span><span class="o">=</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> 
    <span class="n">AOI</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">img_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="o">=</span><span class="n">Vegetation_mask</span><span class="p">,</span> 
    <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="n">VEL_Mode</span><span class="p">,</span> <span class="n">shapefile_output</span><span class="o">=</span><span class="n">shapefile_output</span><span class="p">,</span> 
    <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> 
    <span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
    <span class="n">master_reference</span><span class="o">=</span><span class="n">master_reference</span><span class="p">,</span> <span class="n">selection_Mode</span><span class="o">=</span><span class="n">selection_Mode</span> <span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span> <span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">,</span> <span class="n">dense_match_option</span><span class="o">=</span><span class="n">dense_match_option</span><span class="p">):</span>
        
        <span class="n">folder_path</span> <span class="o">=</span> <span class="n">folder_path</span>
        
        <span class="n">images</span><span class="p">,</span> <span class="n">bound_list</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">,</span> <span class="n">image_path_list</span><span class="p">,</span> <span class="n">filtered_dates</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">maskNan</span> <span class="o">=</span> <span class="n">crop_to_overlap</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
        <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">))]</span>

        <span class="n">image_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">image_files</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">image_files</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">filtered_dates</span><span class="p">]</span>

        <span class="c1">#image_files = sorted(os.listdir(folder_path))</span>
        <span class="c1"># images = []</span>
        <span class="c1"># keypoints = []</span>
        <span class="c1"># descriptors = []</span>
        <span class="c1"># bound_list=[]</span>
        <span class="c1"># # List of valid extensions</span>
        <span class="c1"># valid_extensions = [&#39;.tif&#39;, &#39;.jpg&#39;, &#39;.png&#39;, &#39;.bmp&#39;]</span>
        <span class="c1"># image_path_list=[]</span>
        <span class="c1"># for file in image_files :</span>
        <span class="c1">#     if os.path.splitext(file)[1] in valid_extensions:</span>
        <span class="c1">#         image_path = os.path.join(folder_path,file)</span>
        <span class="c1">#         image_path_list.append(image_path)</span>
        <span class="c1">#         with rasterio.open(image_path) as src:</span>
        <span class="c1">#             image = np.dstack([src.read(i) for i in src.indexes])  # This line stacks the bands of the image</span>
        <span class="c1">#             bounds=src.bounds</span>
        <span class="c1">#             bound_list.append(bounds)</span>
        <span class="c1">#             #image=src.read(1)</span>
        <span class="c1">#         images.append(image)</span>
        <span class="c1">#         kp, des = detect_keypoints(image)</span>
        <span class="c1">#         keypoints.append(kp)</span>
        <span class="c1">#         descriptors.append(des)</span>


        
        <span class="c1">######################</span>
        <span class="n">mean_vel_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">mean_flowx_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">mean_flowy_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pointx_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pointsy_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">dates_names_list</span><span class="o">=</span><span class="p">[]</span>

        <span class="n">lf</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">zoom</span>
            <span class="n">mask_file</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Vegetation_mask</span><span class="p">)</span>
            <span class="n">mask_data</span><span class="o">=</span><span class="n">mask_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ensure mask_data is boolean (0 or 1)</span>
            
        <span class="n">dem_src</span><span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dem_path</span><span class="p">)</span>  
        <span class="n">dem_crs</span><span class="o">=</span><span class="n">dem_src</span><span class="o">.</span><span class="n">crs</span>

        <span class="n">geodfs_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">geodfs_y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">geodfs_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_figs</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">figure_paths</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="c1">############################</span>
        <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
            <span class="n">loop_flag</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
            <span class="n">loop_flag</span><span class="o">=</span><span class="mi">2</span>
        
        <span class="c1">############################</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span><span class="o">-</span><span class="n">loop_flag</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing&quot;</span><span class="p">):</span>
            <span class="n">bound</span><span class="o">=</span><span class="n">bound_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image1</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image2</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">image3</span><span class="o">=</span><span class="n">images</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]</span>
            
           
                
            
            
            <span class="c1">############################</span>
            <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
                <span class="n">image3</span><span class="o">=</span><span class="n">image2</span>
            <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
                <span class="n">image3</span><span class="o">=</span><span class="n">image3</span>
            
            <span class="c1">############################</span>
            <span class="n">keypoints1</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">keypoints2</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">keypoints3</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]</span>
            <span class="n">descriptors1</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">descriptors2</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">descriptors3</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If the shapes don&#39;t match and dem_array is provided, resize mask_array</span>
                <span class="k">if</span> <span class="n">image1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">y_scale</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x_scale</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">mask_data</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">(</span><span class="n">y_scale</span><span class="p">,</span> <span class="n">x_scale</span><span class="p">))</span>

                    <span class="c1"># Threshold mask_array</span>
                    <span class="n">mask_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_data</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">mask_data</span> <span class="o">=</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                
                <span class="c1"># Apply the mask for each band using broadcasting</span>
                <span class="n">image1</span><span class="p">[</span><span class="o">~</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">image2</span><span class="p">[</span><span class="o">~</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">image3</span><span class="p">[</span><span class="o">~</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># plt.imshow(image1)</span>
                <span class="c1"># plt.show()</span>



            <span class="c1"># descriptors1 and descriptors2 are assumed to be numpy arrays</span>
            <span class="n">descriptors12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">descriptors13</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">keypoints12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">keypoints1</span><span class="p">,</span> <span class="n">keypoints2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">keypoints13</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">keypoints1</span><span class="p">,</span> <span class="n">keypoints3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">dense_match_option</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
                <span class="n">good_matches12</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">keypoints12</span> <span class="o">=</span> <span class="n">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">,</span> <span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">)</span>
                <span class="n">good_matches13</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">keypoints13</span> <span class="o">=</span> <span class="n">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">,</span><span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="n">good_matches12</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">keypoints12</span> <span class="o">=</span> <span class="n">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">,</span> <span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">)</span>
                <span class="n">good_matches13</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">keypoints13</span> <span class="o">=</span> <span class="n">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">,</span><span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">)</span>

            <span class="n">flow12</span><span class="p">,</span> <span class="n">flowx12</span><span class="p">,</span> <span class="n">flowy12</span> <span class="p">,</span> <span class="n">ssim1</span><span class="o">=</span> <span class="n">calculate_optical_flow</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span> <span class="p">,</span>
                                                              <span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">orbit_dir</span><span class="o">=</span><span class="n">orbit_dir</span><span class="p">)</span>
            
            <span class="n">flow13</span><span class="p">,</span> <span class="n">flowx13</span><span class="p">,</span> <span class="n">flowy13</span> <span class="p">,</span> <span class="n">ssim2</span><span class="o">=</span> <span class="n">calculate_optical_flow</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">,</span>
                                                              <span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span> <span class="n">orbit_dir</span><span class="o">=</span><span class="n">orbit_dir</span><span class="p">)</span>

            <span class="n">flow</span><span class="o">=</span><span class="n">mean_of_arrays</span><span class="p">(</span><span class="n">flow12</span><span class="p">,</span> <span class="n">flow13</span><span class="p">)</span>
            <span class="n">flowx</span><span class="o">=</span><span class="n">mean_of_arrays</span><span class="p">(</span><span class="n">flowx12</span><span class="p">,</span> <span class="n">flowx13</span><span class="p">)</span>
            <span class="n">flowy</span><span class="o">=</span><span class="n">mean_of_arrays</span><span class="p">(</span><span class="n">flowy12</span><span class="p">,</span><span class="n">flowy13</span><span class="p">)</span>
            
            <span class="n">ssim</span><span class="o">=</span><span class="p">(</span><span class="n">ssim1</span><span class="o">+</span><span class="n">ssim2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

            <span class="n">vel</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span> <span class="o">=</span> <span class="n">filter_velocity</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">good_matches12</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">)</span>
            <span class="n">flowx</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span> <span class="o">=</span> <span class="n">filter_velocity</span><span class="p">(</span><span class="n">flowx</span><span class="p">,</span> <span class="n">good_matches12</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">)</span>
            <span class="n">flowy</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span> <span class="o">=</span> <span class="n">filter_velocity</span><span class="p">(</span><span class="n">flowy</span><span class="p">,</span> <span class="n">good_matches12</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">)</span>
            
            <span class="c1"># vel13, points1, points3 = filter_velocity(flow13, good_matches13, keypoints12, keypoints13)</span>
            <span class="c1"># flowx13, points1, points3 = filter_velocity(flowx13, good_matches13, keypoints12, keypoints13)</span>
            <span class="c1"># flowy13, points1, points3 = filter_velocity(flowy13, good_matches13, keypoints12, keypoints13)</span>

            <span class="c1"># points12 = np.concatenate((points1_i[:,0], points2[:,1]), axis=0)</span>
            <span class="c1"># points13 = np.concatenate((points1[:,0], points3[:,1]), axis=0)</span>

            <span class="c1"># print(points12.shape)</span>
            <span class="c1"># print(points13.shape)</span>

            <span class="c1">#Extract All dates to List for Later use</span>
            <span class="c1"># if master_reference:</span>
            <span class="c1">#     date1 = (extract_date_from_filename(image_files[0])).replace(&quot;-&quot;, &quot;&quot;)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     date1 = (extract_date_from_filename(image_files[lf])).replace(&quot;-&quot;, &quot;&quot;)</span>
            <span class="n">date1</span> <span class="o">=</span> <span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">lf</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">start_date_init</span><span class="o">=</span><span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">date2</span> <span class="o">=</span> <span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">lf</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">date3</span><span class="o">=</span> <span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">lf</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            
             <span class="c1">############################</span>
            <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
                <span class="n">date3</span><span class="o">=</span><span class="n">date2</span>
            <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
                <span class="n">date3</span><span class="o">=</span><span class="n">date3</span>
            
            <span class="c1">############################</span>
            
            <span class="n">lf</span><span class="o">=</span><span class="n">lf</span><span class="o">+</span><span class="mi">1</span>

            <span class="n">time_interval_1_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date2</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date1</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">days</span>
            <span class="n">time_interval_1_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date3</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date1</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">days</span>
            <span class="k">if</span> <span class="n">time_interval_1_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping computation for </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s2"> as the time interval is zero.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip the rest of this loop iteration</span>
            
            <span class="k">if</span> <span class="n">time_interval_1_2</span> <span class="o">&gt;</span> <span class="n">max_triplet_interval</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping computation for </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s2"> as the time interval is larger than </span><span class="si">{</span><span class="n">max_triplet_interval</span><span class="si">}</span><span class="s2"> days.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip the rest of this loop iteration</span>
            
            <span class="k">if</span> <span class="n">time_interval_1_3</span> <span class="o">&gt;</span> <span class="n">max_triplet_interval</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping computation for </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date3</span><span class="si">}</span><span class="s2"> as the time interval is larger than </span><span class="si">{</span><span class="n">max_triplet_interval</span><span class="si">}</span><span class="s2"> days.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip the rest of this loop iteration</span>
        
            
            <span class="n">conversion_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">img_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 1 pixel = 0.1 centimeter, meter, or mm etc..</span>

            <span class="c1">############################</span>
            <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
                <span class="n">time_interval_1_3</span><span class="o">=</span><span class="n">time_interval_1_2</span>
            <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
                <span class="n">time_interval_1_3</span><span class="o">=</span><span class="n">time_interval_1_3</span>
            
            <span class="c1">############################</span>
        
            <span class="n">vel</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span> <span class="o">=</span> <span class="n">calculate_velocity_displacement</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span> <span class="p">,</span> <span class="n">time_interval_1_3</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="p">)</span>
            

            <span class="n">mean_vel_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>
            <span class="n">mean_flowx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flowx</span><span class="p">)</span>
            <span class="n">mean_flowy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flowy</span><span class="p">)</span>
            <span class="n">pointx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points1_i</span><span class="p">)</span>
            <span class="n">pointsy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points2</span><span class="p">)</span>

            <span class="n">X_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/flowx/&quot;</span> 
            <span class="n">Y_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/flowy/&quot;</span>
            <span class="n">VEL_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/vel/&quot;</span>
            <span class="n">plot_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/plots/&quot;</span>

            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">X_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">X_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">Y_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">Y_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">VEL_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">VEL_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            

            <span class="n">file_name_x</span><span class="o">=</span><span class="n">X_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">file_name_y</span><span class="o">=</span><span class="n">Y_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">file_name_vel</span><span class="o">=</span><span class="n">VEL_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">plot_name</span><span class="o">=</span><span class="n">plot_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>

            <span class="n">dates_names_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">))</span>
            
           <span class="c1">#####export ssim raster for later use########</span>
                
            <span class="c1"># Step 1: Read metadata from the reference raster</span>
            <span class="c1"># with rasterio.open(dem_path) as ref_raster:</span>
            <span class="c1">#     ref_meta = ref_raster.meta</span>
            <span class="c1">#     ref_meta.update({</span>
            <span class="c1">#     &#39;height&#39;: image1.shape[0],</span>
            <span class="c1">#     &#39;width&#39;: image1.shape[1]</span>
            <span class="c1"># })</span>
              
            <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;float32&#39;</span> <span class="p">,</span> <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">})</span>
            <span class="n">ssim</span><span class="p">[</span><span class="n">ssim</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ssim</span><span class="p">[</span><span class="n">ssim</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ssim</span><span class="p">[</span><span class="n">maskNan</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ssim_outdir</span><span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span><span class="s2">&quot;/ssim&quot;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ssim_outdir</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ssim_outdir</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">ssim_outdir_fname</span><span class="o">=</span><span class="n">ssim_outdir</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;.tif&quot;</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">ssim_outdir_fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst_ssim</span><span class="p">:</span>
                    <span class="n">dst_ssim</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ssim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            
            
            <span class="c1">##########################################</span>
            
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">fig_and_axes</span><span class="o">=</span> <span class="n">plot_velocity_displacement</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">date1</span><span class="p">,</span> <span class="n">date3</span><span class="p">,</span> <span class="n">pdf_filename</span><span class="o">=</span><span class="n">plot_name</span><span class="p">,</span> <span class="n">time_interval</span><span class="o">=</span><span class="n">time_interval_1_3</span> <span class="p">,</span> 
                                             <span class="n">show_figure</span><span class="o">=</span><span class="n">show_figure</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">point_size</span><span class="p">,</span>
                                               <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="n">bound</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">bound</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">bound</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bound</span><span class="o">.</span><span class="n">top</span><span class="p">])</span>
            
            <span class="n">list_figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig_and_axes</span><span class="p">)</span>
            <span class="n">figure_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_name</span><span class="p">)</span>
            <span class="c1">############### flowx To Point Shapefile ####################</span>
            
            <span class="n">dfx</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">dfx</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
            <span class="n">dfx</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">z_data</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">dfx</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">=</span><span class="n">flowx</span>
            <span class="c1"># Change the dtype of a specific column to float32</span>
            <span class="n">dfx</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfx</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">gdfx</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">dfx</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">dfx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dfx</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

            <span class="c1">#geodfs_x.append(gdfx)</span>

            <span class="c1">############### flowy To Point Shapefile ####################</span>
            <span class="n">dfy</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">dfy</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
            <span class="n">dfy</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">z_data</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">dfy</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">=</span><span class="n">flowy</span>
            <span class="c1"># Change the dtype of a specific column to float32</span>
            <span class="n">dfy</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfy</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">gdfy</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">dfy</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">dfy</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dfy</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            

            <span class="c1">############### 2D_Vel To Point Shapefile ####################</span>
            <span class="n">dfv</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">dfv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
            <span class="n">dfv</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">z_data</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">dfv</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">=</span> <span class="n">vel</span>
            <span class="c1"># Change the dtype of a specific column to float32</span>
            <span class="n">dfv</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfv</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">gdfv</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">dfv</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">dfv</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dfv</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            
           
            <span class="c1">#############################</span>

            <span class="c1"># east_x, east_y, east_z, gdfx=interpolate_kriging_nans_geodataframe(data=gdfx, </span>
            <span class="c1">#  threshold=None, variogram_model=None, out_fileName=None, plot=False)</span>

            <span class="c1"># north_x, north_y, north_z, gdfy=interpolate_kriging_nans_geodataframe(data=gdfy, </span>
            <span class="c1">#  threshold=None, variogram_model=None, out_fileName=None, plot=False)</span>

            <span class="c1"># vel2D_x, vel2D_y, vel2D_z, gdfv=interpolate_kriging_nans_geodataframe(data=gdfv, </span>
            <span class="c1">#  threshold=None, variogram_model=None, out_fileName=None, plot=False)</span>
            
            
            
            <span class="n">east_z</span><span class="o">=</span><span class="n">flowx</span>
            <span class="n">north_z</span><span class="o">=</span><span class="n">flowy</span>
            <span class="n">vel2D_z</span><span class="o">=</span><span class="n">vel</span>
            
            <span class="n">geodfs_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdfx</span><span class="p">)</span>
            <span class="n">geodfs_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdfy</span><span class="p">)</span>
            <span class="n">geodfs_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdfv</span><span class="p">)</span>

            <span class="n">gdfx</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">gdfy</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">gdfv</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            
            <span class="k">if</span> <span class="n">interpolate</span><span class="o">==</span><span class="s1">&#39;kriging&#39;</span><span class="p">:</span>
                

                <span class="n">plot_folder_x</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/kriging_plots_x/&#39;</span>
                <span class="n">plot_folder_Y</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/kriging_plots_y/&#39;</span>
                <span class="n">plot_folder_VEL</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/kriging_plots_2dvel/&#39;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder_x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder_x</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder_Y</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder_Y</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder_VEL</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder_VEL</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                
                <span class="n">fname_rasters</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
                
                
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Auto_Variogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gdfx</span><span class="p">,</span> <span class="n">column_attribute</span><span class="o">=</span><span class="n">z_data</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aoi_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> 
                                <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> <span class="n">out_fileName</span><span class="o">=</span><span class="n">fname_rasters</span><span class="p">,</span> 
                                <span class="n">plot_folder</span><span class="o">=</span><span class="n">plot_folder_x</span><span class="p">,</span>  <span class="n">smoothing_kernel</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">geo_folder</span><span class="o">=</span><span class="n">X_folder</span><span class="p">,</span> <span class="n">krig_method</span><span class="o">=</span><span class="n">krig_method</span><span class="p">,</span> <span class="n">detrend_data</span><span class="o">=</span><span class="n">use_detrend</span><span class="p">,</span> <span class="n">use_zscore</span><span class="o">=</span><span class="n">use_zscore_krig</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto_Variogram failed with error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">east_z</span><span class="p">,</span> <span class="n">file_name_x</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Auto_Variogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gdfy</span><span class="p">,</span> <span class="n">column_attribute</span><span class="o">=</span><span class="n">z_data</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aoi_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span>
                                <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> <span class="n">out_fileName</span><span class="o">=</span><span class="n">fname_rasters</span><span class="p">,</span> 
                                <span class="n">plot_folder</span><span class="o">=</span><span class="n">plot_folder_Y</span><span class="p">,</span> <span class="n">smoothing_kernel</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">geo_folder</span><span class="o">=</span><span class="n">Y_folder</span><span class="p">,</span> <span class="n">krig_method</span><span class="o">=</span><span class="n">krig_method</span><span class="p">,</span> <span class="n">detrend_data</span><span class="o">=</span><span class="n">use_detrend</span><span class="p">,</span> <span class="n">use_zscore</span><span class="o">=</span><span class="n">use_zscore_krig</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto_Variogram failed with error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">north_z</span><span class="p">,</span> <span class="n">file_name_y</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span> <span class="p">)</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Auto_Variogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gdfv</span><span class="p">,</span> <span class="n">column_attribute</span><span class="o">=</span><span class="n">z_data</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aoi_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> 
                                <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> <span class="n">out_fileName</span><span class="o">=</span><span class="n">fname_rasters</span><span class="p">,</span> 
                                <span class="n">plot_folder</span><span class="o">=</span><span class="n">plot_folder_VEL</span><span class="p">,</span> <span class="n">smoothing_kernel</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">geo_folder</span><span class="o">=</span><span class="n">VEL_folder</span><span class="p">,</span> <span class="n">krig_method</span><span class="o">=</span><span class="n">krig_method</span><span class="p">,</span> <span class="n">detrend_data</span><span class="o">=</span><span class="n">use_detrend</span><span class="p">,</span> <span class="n">use_zscore</span><span class="o">=</span><span class="n">use_zscore_krig</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto_Variogram failed with error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vel2D_z</span><span class="p">,</span> <span class="n">file_name_vel</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span> <span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                   
                <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">east_z</span><span class="p">,</span> <span class="n">file_name_x</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span> <span class="p">)</span>
                <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">north_z</span><span class="p">,</span> <span class="n">file_name_y</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span> <span class="p">)</span>
                <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vel2D_z</span><span class="p">,</span> <span class="n">file_name_vel</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span> <span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">X_folder</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="p">)</span>
            <span class="n">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">Y_folder</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="p">)</span>
            <span class="n">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">VEL_folder</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="p">)</span>
            
            
        <span class="n">dates_list</span><span class="o">=</span><span class="p">[</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">image_files</span><span class="p">]</span>
        <span class="c1"># Filter image_files based on extensions and extract dates</span>
        <span class="c1"># image_extensions = [&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;, &#39;.tif&#39;, &#39;.tiff&#39;]</span>
        <span class="c1"># dates_list = [extract_date_from_filename(filename) for filename in image_files if os.path.splitext(filename)[1].lower() in image_extensions]</span>
            
        <span class="n">Total_days</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">image_files</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">days</span>
        
        
        <span class="c1"># # Concatenate GeoDataFrames</span>
        <span class="c1"># geodfs_x = pd.concat(geodfs_x, axis=0).reset_index(drop=True)</span>
        <span class="c1"># geodfs_y = pd.concat(geodfs_y, axis=0).reset_index(drop=True)</span>
        <span class="c1"># geodfs_v = pd.concat(geodfs_v, axis=0).reset_index(drop=True)</span>
        

        
 
        <span class="k">if</span> <span class="n">shapefile_output</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            
            <span class="n">shapefile_temp_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="s2">&quot;temp_shapefile_dir&quot;</span>
            
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">shapefileName</span><span class="o">=</span><span class="n">shapefile_temp_dir</span> <span class="o">+</span><span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_date_init</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Wait for processing to complete writing data into shapefile for timeseries...&#39;</span><span class="p">)</span>
            
           
            <span class="n">geodfs_x</span><span class="o">=</span><span class="n">merge_geodataframes</span><span class="p">(</span><span class="n">geodfs_x</span><span class="p">)</span>
            <span class="n">geodfs_x</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">geodfs_x</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_E.shp&#39;</span><span class="p">)</span>
            
            <span class="k">del</span> <span class="n">geodfs_x</span>
            
            <span class="n">geodfs_y</span><span class="o">=</span><span class="n">merge_geodataframes</span><span class="p">(</span><span class="n">geodfs_y</span><span class="p">)</span>
            <span class="c1">#######################3######</span>
        
            <span class="n">geodfs_y</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">geodfs_y</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_N.shp&#39;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">geodfs_y</span>
            <span class="c1">###########################</span>
           
            <span class="n">geodfs_v</span><span class="o">=</span><span class="n">merge_geodataframes</span><span class="p">(</span><span class="n">geodfs_v</span><span class="p">)</span>
            <span class="c1">#print(&quot;DataFrame 2DVEL Summary:\n&quot;, geodfs_v.describe())</span>
            <span class="n">geodfs_v</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">geodfs_v</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shapefileName</span> <span class="o">+</span> <span class="s1">&#39;_2DVEL.shp&#39;</span><span class="p">)</span>
            
            <span class="k">del</span> <span class="n">geodfs_v</span>
           
            
            <span class="c1"># ####3Look for stable pixel###########</span>
            <span class="c1"># os.makedirs(ssim_outdir + &#39;/cropped&#39;, exist_ok=True)</span>

            <span class="c1"># Crop_to_AOI(Path_to_WorkingDir=ssim_outdir, </span>
            <span class="c1">#                   Path_to_AOI_shapefile=AOI, </span>
            <span class="c1">#                   output_CroppedDir=ssim_outdir+ &#39;/cropped&#39;, file_ex=&#39;.tif&#39;)</span>
            <span class="c1"># gdf_ssim=process_shapefile_with_rasters(shapefileName +&#39;_E.shp&#39;, ssim_outdir + &#39;/cropped&#39;)</span>
            <span class="c1"># #print(gdf_ssim.ssim_V.iloc[reference_index])</span>
            <span class="c1"># gdf_ssim.crs=dem_crs</span>
            <span class="c1"># gdf_ssim.to_file(output_dir+&quot;/ssim_E.shp&quot;)</span>
            
            <span class="c1"># ###########3</span>
            <span class="c1"># gdf_ssim=process_shapefile_with_rasters(shapefileName +&#39;_N.shp&#39;, ssim_outdir + &#39;/cropped&#39;)</span>
            <span class="c1"># #print(gdf_ssim.ssim_V.iloc[reference_index])</span>
            <span class="c1"># gdf_ssim.crs=dem_crs</span>
            <span class="c1"># gdf_ssim.to_file(output_dir+&quot;/ssim_N.shp&quot;)</span>
            
        
            <span class="c1"># ########</span>
            
            <span class="c1"># gdf_ssim=process_shapefile_with_rasters(shapefileName +&#39;_E.shp&#39;, ssim_outdir + &#39;/cropped&#39;)</span>
            <span class="c1"># #print(gdf_ssim.ssim_V.iloc[reference_index])</span>
            <span class="c1"># gdf_ssim.crs=dem_crs</span>
            <span class="c1"># gdf_ssim.to_file(output_dir+&quot;/ssim_2DVEL.shp&quot;)</span>
            <span class="c1">#################</span>
            

            <span class="k">if</span> <span class="n">use_detrend</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
                <span class="n">raster_folder</span><span class="o">=</span><span class="p">[</span><span class="n">VEL_folder</span><span class="o">+</span><span class="s2">&quot;/detrend&quot;</span><span class="p">,</span> <span class="n">Y_folder</span><span class="o">+</span><span class="s2">&quot;/detrend&quot;</span><span class="p">,</span> <span class="n">X_folder</span><span class="o">+</span><span class="s2">&quot;/detrend&quot;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raster_folder</span><span class="o">=</span><span class="p">[</span><span class="n">VEL_folder</span><span class="p">,</span> <span class="n">Y_folder</span><span class="p">,</span> <span class="n">X_folder</span><span class="p">]</span>
                
            <span class="c1">#SSIM_shape_list=[shapefileName +&#39;_E.shp&#39;, shapefileName +&#39;_N.shp&#39;, shapefileName +&#39;_2DVEL.shp&#39;]</span>
            
            <span class="c1">####Loop to update raster to crop to AOI#####3</span>
            <span class="kn">import</span> <span class="nn">shutil</span> 
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">raster_folder</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing:Updating and Cropping Rasters&quot;</span><span class="p">)):</span>
                
                 
                <span class="n">cropped_dir</span><span class="o">=</span><span class="n">raster_folder</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/cropped&#39;</span>
               
                <span class="c1"># Check if the subdirectory exists</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">):</span>
                    <span class="c1"># Remove the existing subdirectory</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">)</span>

                <span class="c1"># # Create the subdirectory again</span>
                <span class="c1"># os.makedirs(sub_dir_path, exist_ok=True)</span>
                
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">Crop_to_AOI</span><span class="p">(</span><span class="n">Path_to_WorkingDir</span><span class="o">=</span><span class="n">raster_folder</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">Path_to_AOI_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> <span class="n">output_CroppedDir</span><span class="o">=</span><span class="n">cropped_dir</span><span class="p">,</span> <span class="n">file_ex</span><span class="o">=</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
            
            <span class="kn">import</span> <span class="nn">time</span>
            <span class="c1"># Wait for 10 seconds</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            
            <span class="n">list_shp_paths</span><span class="o">=</span><span class="p">[]</span>
            <span class="n">data_list</span><span class="o">=</span><span class="p">[</span><span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_2DVEL.shp&#39;</span><span class="p">,</span> <span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_N.shp&#39;</span><span class="p">,</span> <span class="n">shapefileName</span> <span class="o">+</span> <span class="s1">&#39;_E.shp&#39;</span> <span class="p">]</span>
            <span class="c1">######################################</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing: Update Shapefiles &quot;</span> <span class="p">)):</span>
                <span class="n">cropped_dir</span><span class="o">=</span><span class="n">raster_folder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/cropped&#39;</span>
               
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;processing </span><span class="si">{</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> started... &#39;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="n">updated_geodf</span><span class="p">,</span> <span class="n">update_shapefile_dir</span><span class="o">=</span><span class="n">update_nodata_values</span><span class="p">(</span><span class="n">shapefile_path</span><span class="o">=</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rasterfile_paths</span><span class="o">=</span><span class="n">cropped_dir</span><span class="p">,</span><span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="n">VEL_Mode</span> <span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span> <span class="p">,</span>
                                     <span class="n">master_reference</span><span class="o">=</span><span class="n">master_reference</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="n">Total_days</span><span class="p">,</span> <span class="n">spatial_ref</span><span class="o">=</span><span class="n">spatial_ref</span><span class="p">)</span>
                <span class="n">list_shp_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">update_shapefile_dir</span><span class="p">)</span>
                
                
                <span class="c1"># update_nodata_values(shapefile_path=data_list[i], rasterfile_paths=cropped_dir,interpolate=False, VEL_Mode=VEL_Mode , VEL_scale=VEL_scale ,</span>
                <span class="c1">#                      master_reference=master_reference, Total_days=Total_days, reference_index=best_match_index)</span>
                
                <span class="c1">#update_nodata_values(shapefile_path=data_list[k], rasterfile_paths=raster_folder[k],interpolate=False, VEL_Mode=VEL_Mode , VEL_scale=VEL_scale , master_reference=master_reference, Total_days=Total_days)</span>
                <span class="c1">#update_nodata_values(shapefile_path=data_list[k], rasterfile_paths=raster_folder[k],interpolate=False, VEL_Mode=VEL_Mode , VEL_scale=VEL_scale , master_reference=master_reference, Total_days=Total_days)</span>

                <span class="c1"># interpolate_kriging_nans_geodataframe(data=data_list[k], </span>
                <span class="c1">#     threshold=None, variogram_model=None, out_fileName=None, plot=False, </span>
                <span class="c1">#     Total_days=Total_days,VEL_scale=VEL_scale, VEL_Mode=VEL_Mode)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;processing </span><span class="si">{</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> completed... &#39;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            
           
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Total Days: </span><span class="si">{</span><span class="n">Total_days</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/Names.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dates_names_list</span><span class="p">:</span>
                <span class="c1"># write each item on a new line</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>

        
        <span class="k">def</span> <span class="nf">find_file</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">xml_file_path</span><span class="o">=</span><span class="n">find_file</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">,</span> <span class="s2">&quot;_2DVEL.shp.xml&quot;</span><span class="p">)</span>
        
       
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file used&quot;</span><span class="p">,</span> <span class="n">xml_file_path</span><span class="p">)</span>
       <span class="c1"># Check if the file exists</span>
        <span class="k">if</span> <span class="n">xml_file_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_reference_point</span><span class="p">(</span><span class="n">xml_file_path</span><span class="p">,</span> <span class="n">list_figs</span><span class="p">,</span> <span class="n">figure_paths</span><span class="p">)</span>
            
            
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;start calculating aspect...&quot;</span><span class="p">)</span>
        
       
        <span class="n">gdfe</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">list_shp_paths</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">gdfn</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">list_shp_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">gdfv</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">list_shp_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        
        <span class="n">gdf_crs</span><span class="o">=</span><span class="n">gdfe</span><span class="o">.</span><span class="n">crs</span>
        
        <span class="c1"># Calculate aspect for gdf1</span>
        <span class="c1">###############</span>
        <span class="n">aspect</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">gdfe</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">],</span> <span class="n">gdfn</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">])</span>
        <span class="n">aspect_deg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
        <span class="n">aspect_deg</span> <span class="o">=</span> <span class="p">(</span><span class="mi">450</span> <span class="o">-</span><span class="n">aspect_deg</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        <span class="c1">##############3</span>
       
        <span class="n">gdfe</span><span class="p">[</span><span class="s1">&#39;aspect&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aspect_deg</span>

        <span class="c1"># Calculate aspect for gdf2</span>
        
        
        <span class="n">gdfn</span><span class="p">[</span><span class="s1">&#39;aspect&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aspect_deg</span>      
        <span class="c1"># Calculate aspect for gdf2</span>
        
        <span class="n">gdfv</span><span class="p">[</span><span class="s1">&#39;aspect&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">aspect_deg</span>                                   
        
        <span class="n">gdfe</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">list_shp_paths</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;ESRI Shapefile&#39;</span><span class="p">)</span>
        <span class="n">gdfn</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">list_shp_paths</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;ESRI Shapefile&#39;</span><span class="p">)</span>
        <span class="n">gdfv</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">list_shp_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;ESRI Shapefile&#39;</span><span class="p">)</span>
        
        
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;calculating aspect completed&quot;</span><span class="p">)</span>
        
        <span class="c1">#print(f&#39;Dates: {dates_list}&#39;)</span>

    <span class="c1">#     data=[dates_list,pointx_list, pointsy_list, mean_flowx_list, mean_flowy_list,mean_vel_list ]</span>
    <span class="c1">#    # Create DataFrame</span>
    <span class="c1">#     df = pd.DataFrame(data, columns=column_names)</span>

        <span class="c1"># Free up memory by manually invoking garbage collection</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="c1">#image1, image3, mean_vel_list, mean_flowx_list, mean_flowy_list, points1_i, points2, dates_list[0], dates_list[len(dates_list)-1]</span>
        
        <span class="c1">#return </span>

    <span class="n">feature_matching</span><span class="p">(</span><span class="n">folder_path</span><span class="o">=</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">AOI</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">img_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">)</span></div>


   

    
<span class="c1">#######################################</span>



<div class="viewcode-block" id="interpolate_xyz">
<a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.interpolate_xyz">[docs]</a>
<span class="k">def</span> <span class="nf">interpolate_xyz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">reference_raster</span><span class="p">,</span> <span class="n">shapefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save XYZ data as a GeoTIFF file using a reference raster for geospatial context.</span>

<span class="sd">    This function takes X, Y, Z coordinate data and generates a GeoTIFF file. The geospatial context</span>
<span class="sd">    is derived from a reference raster file. The function supports optional interpolation of Z values,</span>
<span class="sd">    spatial smoothing, and masking based on a shapefile or a predefined  mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x (array_like): Array of X coordinates.</span>
<span class="sd">        y (array_like): Array of Y coordinates.</span>
<span class="sd">        z (array_like): Array of Z values corresponding to X and Y coordinates.</span>
<span class="sd">        filename (str): The base name of the output GeoTIFF file (without file extension).</span>
<span class="sd">        reference_raster (str): Path to the reference raster file used for spatial context (CRS, bounds, etc.).</span>
<span class="sd">        shapefile (str, optional): Path to a shapefile for masking the output raster. Defaults to None.</span>
<span class="sd">        interpolate (str, optional): Interpolation method to be used (e.g., &#39;linear&#39;, &#39;nearest&#39;). If None, a nearest-neighbor approach is applied. Defaults to None.</span>
<span class="sd">        smoothing_kernel_size (int or float, optional): The size of the Gaussian kernel used for smoothing the Z values. Defaults to None.</span>
<span class="sd">        mask (array_like, optional): A boolean mask array to mask vegetation areas. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The array of interpolated/smoothed Z values, which is also saved as a GeoTIFF file.</span>

<span class="sd">    Raises:</span>
<span class="sd">        Exception: If an error occurs during the process.</span>

<span class="sd">        Notes:</span>
<span class="sd">        - The function uses `rasterio` for raster operations and `numpy` and `scipy` for data processing.</span>
<span class="sd">        - The output GeoTIFF file will have the same spatial extent, resolution, and coordinate reference system (CRS) as the reference raster.</span>
<span class="sd">        - If &#39;interpolate&#39; is not None, Z values are interpolated over the grid defined by the reference raster. Out-of-range interpolated values are replaced with the mean of valid data points.</span>
<span class="sd">        - If &#39;smoothing_kernel_size&#39; is provided, a Gaussian smoothing is applied to the Z values.</span>
<span class="sd">        - Masking with either a shapefile or a vegetation mask will set the corresponding areas to NaN.</span>
<span class="sd">        - The output file is named using the &#39;filename&#39; parameter with &#39;.tif&#39; extension.</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Get the CRS, width, height, and transform from the reference raster</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">reference_raster</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">left</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span>
            <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            

        <span class="c1"># Create a 2D grid of coordinates based on the x, y values</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

        <span class="c1"># Create an array of the same size as the x, y grid filled with NaN</span>
        <span class="c1">#zi = np.full_like(xi, yi, np.nan)</span>
        <span class="c1">#zi = np.zeros_like(xi)</span>

        
            

        <span class="k">if</span> <span class="n">interpolate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Interpolate z values onto the new grid</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Replace interpolated values outside the range with mean of initial z values</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&lt;</span> <span class="n">z_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&gt;</span> <span class="n">z_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="c1"># Find the indices of interpolated points exceeding the data range</span>
            <span class="n">out_of_range_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">xi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">yi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

            <span class="c1"># Replace out-of-range interpolated points with the mean of valid data points</span>
            <span class="n">zi_valid</span> <span class="o">=</span> <span class="n">zi</span><span class="p">[</span><span class="o">~</span><span class="n">out_of_range_indices</span><span class="p">]</span>
            <span class="n">mean_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">zi_valid</span><span class="p">)</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_of_range_indices</span><span class="p">,</span> <span class="n">mean_valid</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zi</span><span class="o">=</span><span class="n">replace_nan_with_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
            <span class="c1"># # Flatten the coordinates grid and build a KDTree</span>
            <span class="c1"># flattened_coordinates = np.column_stack((xi.ravel(), yi.ravel()))</span>
            <span class="c1"># tree = cKDTree(flattened_coordinates)</span>

            <span class="c1"># # Query the tree for nearest neighbors to each point in x, y</span>
            <span class="c1"># _, indices = tree.query(np.column_stack((x, y)))</span>

            <span class="c1"># # Replace NaNs with z values at these indices</span>
            <span class="c1"># np.put(zi, indices, z)</span>
            

            
        
            <span class="c1"># Apply low-pass filter</span>
        <span class="k">if</span> <span class="n">smoothing_kernel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#zi_initial=zi</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothing_kernel_size</span> <span class="p">)</span>  <span class="c1"># Adjust sigma according to your desired smoothing strength</span>
            <span class="c1">#if interpolate is None:</span>
                <span class="c1">#zi[zi_initial == 0] = np.nan</span>

        <span class="k">if</span> <span class="n">shapefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Load shapefile, convert it to the correct CRS and get its geometry</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Generate a mask from the shapes</span>
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">geometry_mask</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">out_shape</span><span class="o">=</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Apply the mask to the interpolated data</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zi</span><span class="o">=</span><span class="n">mask_raster</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">mask</span> <span class="p">)</span>


        <span class="c1"># Define the profile</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
            <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">zi</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">crs</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
            <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># specify the nodata value</span>
        <span class="p">}</span>

        <span class="c1"># Write to a new .tif file</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred while creating the GeoTIFF:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">zi</span></div>

</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
  <span id="sidebar-top"></span>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  
    
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/akhdefo_logo.svg" alt="Logo"/>
            </a></p>
  
<h3>Navigation</h3>
<ul>
  <li><a href="../../index.html">Overview</a>
    <ul>
      <li><a href="../index.html">Module code</a>
        
          
          </ul>
      </li>
    </ul>
  </li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script><div id="ethical-ad-placement"></div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
    <div class="footer" role="contentinfo">
    &#169; Copyright 2024, Mahmud Mustafa Muhammad.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  <script src="../../_static/version_warning_offset.js"></script>

  </body>
</html>