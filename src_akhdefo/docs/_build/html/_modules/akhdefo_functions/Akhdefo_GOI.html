

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>akhdefo_functions.Akhdefo_GOI &#8212; AkhDefo Software 2.2.58 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="../../_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/akhdefo_functions/Akhdefo_GOI';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/akhdefo_logo.svg" class="logo__image only-light" alt="AkhDefo Software 2.2.58 documentation - Home"/>
    <script>document.write(`<img src="../../_static/akhdefo_logo.svg" class="logo__image only-dark" alt="AkhDefo Software 2.2.58 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../README.html">Akhdefo:</a></li>




<li class="toctree-l1 has-children"><a class="reference internal" href="../../modules.html">Documentation</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../../akhdefo_functions.html">akhdefo_functions package</a></li>
</ul>
</li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <h1>Source code for akhdefo_functions.Akhdefo_GOI</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">gdal</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">gc</span>

<div class="viewcode-block" id="mask_raster_with_template"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.mask_raster_with_template">[docs]</a><span class="k">def</span> <span class="nf">mask_raster_with_template</span><span class="p">(</span><span class="n">input_raster_path</span><span class="p">,</span> <span class="n">mask_raster_path</span><span class="p">,</span> <span class="n">noData_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Masks a georeferenced raster file using a binary raster mask template.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - input_raster_path (str): Path to the input georeferenced raster file.</span>
<span class="sd">    - mask_raster_path (str): Path to the binary raster mask template.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None. The input raster file will be replaced by the masked raster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Open the input raster and mask raster</span>
    <span class="n">input_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">input_raster_path</span><span class="p">,</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GA_ReadOnly</span><span class="p">)</span>
    <span class="n">mask_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">mask_raster_path</span><span class="p">,</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GA_ReadOnly</span><span class="p">)</span>

    <span class="c1"># Create memory target raster with same dimensions as input raster</span>
    <span class="n">mem_drv</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GetDriverByName</span><span class="p">(</span><span class="s1">&#39;MEM&#39;</span><span class="p">)</span>
    <span class="n">target_ds</span> <span class="o">=</span> <span class="n">mem_drv</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GDT_Byte</span><span class="p">)</span>
    <span class="n">target_ds</span><span class="o">.</span><span class="n">SetGeoTransform</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">())</span>
    <span class="n">target_ds</span><span class="o">.</span><span class="n">SetProjection</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">())</span>

    <span class="c1"># Reproject mask raster to match input raster</span>
    <span class="n">gdal</span><span class="o">.</span><span class="n">ReprojectImage</span><span class="p">(</span><span class="n">mask_ds</span><span class="p">,</span> <span class="n">target_ds</span><span class="p">,</span> <span class="n">mask_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">(),</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">(),</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GRA_NearestNeighbour</span><span class="p">)</span>
    <span class="n">mask_band</span> <span class="o">=</span> <span class="n">target_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>

    <span class="c1"># Create a temporary file to store masked raster</span>
    <span class="n">temp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">suffix</span><span class="o">=</span><span class="s2">&quot;.tif&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># Loop through bands in input raster and apply mask</span>
    <span class="n">out_ds</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GetDriverByName</span><span class="p">(</span><span class="s1">&#39;GTiff&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">Create</span><span class="p">(</span><span class="n">temp_file</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterCount</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">DataType</span><span class="p">)</span>
    <span class="n">out_ds</span><span class="o">.</span><span class="n">SetGeoTransform</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">())</span>
    <span class="n">out_ds</span><span class="o">.</span><span class="n">SetProjection</span><span class="p">(</span><span class="n">input_ds</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">())</span>

    <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">RasterCount</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">input_band_data</span> <span class="o">=</span> <span class="n">input_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="n">band</span><span class="p">)</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>
        <span class="n">input_band_data</span><span class="p">[</span><span class="n">mask_band</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">noData_value</span>  <span class="c1"># Set pixels to 0 where mask is 0</span>

        <span class="n">out_band</span> <span class="o">=</span> <span class="n">out_ds</span><span class="o">.</span><span class="n">GetRasterBand</span><span class="p">(</span><span class="n">band</span><span class="p">)</span>
        <span class="n">out_band</span><span class="o">.</span><span class="n">WriteArray</span><span class="p">(</span><span class="n">input_band_data</span><span class="p">)</span>
        <span class="n">out_band</span><span class="o">.</span><span class="n">FlushCache</span><span class="p">()</span>

    <span class="n">input_ds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">mask_ds</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">out_ds</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="c1"># Replace original raster with the masked raster</span>
    <span class="c1"># os.remove(input_raster_path)</span>
    <span class="c1"># os.rename(temp_file, input_raster_path)</span>
    <span class="kn">import</span> <span class="nn">shutil</span>
    <span class="n">shutil</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_file</span><span class="p">,</span> <span class="n">input_raster_path</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">temp_file</span><span class="p">)</span></div>



<div class="viewcode-block" id="mask_all_rasters_in_directory"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.mask_all_rasters_in_directory">[docs]</a><span class="k">def</span> <span class="nf">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">mask_raster_path</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Masks all georeferenced raster files in a specified directory using a binary raster mask template.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - directory (str): Path to the directory containing the georeferenced raster files.</span>
<span class="sd">    - mask_raster_path (str): Path to the binary raster mask template.</span>

<span class="sd">    Returns:</span>
<span class="sd">    None. Each raster file in the specified directory will be replaced by its corresponding masked raster.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>  <span class="c1"># This will only list files/directories in the given directory</span>
        <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">)):</span>
            <span class="n">input_raster_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="n">mask_raster_with_template</span><span class="p">(</span><span class="n">input_raster_path</span><span class="p">,</span> <span class="n">mask_raster_path</span><span class="p">)</span></div>


<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">from</span> <span class="nn">pykrige.ok</span> <span class="kn">import</span> <span class="n">OrdinaryKriging</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span>


<span class="c1">#Calculate Linear Velocity for each data point</span>
<div class="viewcode-block" id="linear_VEL"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.linear_VEL">[docs]</a><span class="k">def</span> <span class="nf">linear_VEL</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">dnames</span><span class="p">):</span>
    
    <span class="n">dd_list</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dnames</span><span class="p">]</span>
    <span class="n">dates_list</span><span class="o">=</span><span class="p">([</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dd_list</span><span class="p">])</span>
    <span class="n">days_num</span><span class="o">=</span><span class="p">[(</span> <span class="p">((</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="n">year</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">day</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span><span class="o">.</span><span class="n">days</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dates_list</span><span class="p">]</span>
    <span class="n">days_num</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dnames</span><span class="p">)))</span>
    <span class="n">dslope</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">std_slope</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">dr</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="c1">#if index==0:</span>
        <span class="n">rows</span><span class="o">=</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">row_values</span><span class="o">=</span><span class="n">rows</span>
        <span class="c1"># dfr = pd.DataFrame(dr).transpose()</span>
        <span class="c1"># dfr = dfr.loc[:, ~dfr.columns.str.contains(&#39;^Unnamed&#39;)]</span>
    
        <span class="c1">#slopeVEL=best_fit_slope_and_intercept(days_num, row_values)</span>
        <span class="c1">#print(&quot;slope&quot;, slopeVEL[0])</span>
        <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">r_value</span><span class="p">,</span> <span class="n">p_value</span><span class="p">,</span> <span class="n">std_err</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">days_num</span><span class="p">,</span> <span class="n">row_values</span><span class="p">)</span>
        <span class="n">dslope</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slope</span><span class="p">)</span>
        <span class="n">std_slope</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">std_err</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dslope</span><span class="p">,</span> <span class="n">std_slope</span></div>

<span class="c1"># def replace_outliers_with_nan_zscore(gdf, column_name, threshold):</span>
<span class="c1">#     # Create a copy of the GeoDataFrame to avoid modifying the original</span>
<span class="c1">#     #modified_geodataframe = geodataframe.copy()</span>

<span class="c1">#     # Calculate Z-scores for the specified column</span>
<span class="c1">#     z_scores = np.abs(zscore(gdf[column_name]))</span>

<span class="c1">#     # Replace outliers with NaN values based on the threshold</span>
<span class="c1">#     gdf.loc[z_scores &gt; threshold, column_name] = np.nan</span>

<span class="c1">#     return gdf</span>

<span class="c1"># import numpy as np</span>
<span class="c1"># import geopandas as gpd</span>
<span class="c1"># import gstools as gs</span>
<span class="c1"># import matplotlib.pyplot as plt</span>

<span class="c1"># # Function to fit variogram models and visualize them</span>
<span class="c1"># def fit_variogram_models(x, y, z, latlon=False , show_plot=False):</span>
<span class="c1">#     bin_center, gamma = gs.vario_estimate((x, y), z, latlon=latlon)</span>
    
<span class="c1">#     # Models to test</span>
<span class="c1">#     models = {</span>
<span class="c1">#         &quot;Gaussian&quot;: gs.Gaussian,</span>
<span class="c1">#         &quot;Exponential&quot;: gs.Exponential,</span>
<span class="c1">#         &quot;Matern&quot;: gs.Matern,</span>
<span class="c1">#         &quot;Integral&quot;: gs.Integral,</span>
<span class="c1">#         &quot;Cubic&quot;: gs.Cubic,</span>
<span class="c1">#         &quot;Stable&quot;: gs.Stable,</span>
<span class="c1">#         &quot;Rational&quot;: gs.Rational,</span>
<span class="c1">#         &quot;Spherical&quot;: gs.Spherical,</span>
<span class="c1">#         &quot;SuperSpherical&quot;: gs.SuperSpherical,</span>
<span class="c1">#         &quot;JBessel&quot;: gs.JBessel,</span>
<span class="c1">#         &quot;HyperSpherical&quot;: gs.HyperSpherical,</span>
<span class="c1">#         &quot;TPLSimple&quot;: gs.TPLSimple</span>
<span class="c1">#     }</span>

<span class="c1">#     scores = {}</span>
<span class="c1">#     fig, ax = plt.subplots(figsize=(10, 5))</span>
<span class="c1">#     ax.scatter(bin_center, gamma, color=&quot;k&quot;, label=&quot;Empirical&quot;)</span>

<span class="c1">#     best_model, best_score, best_fit = None, -10, None</span>
    
<span class="c1">#     for model_name, Model in models.items():</span>
<span class="c1">#         try:</span>
<span class="c1">#             fit_model = Model(dim=2)</span>
<span class="c1">#             _, _, r2 = fit_model.fit_variogram(bin_center, gamma, return_r2=True)</span>
<span class="c1">#             scores[model_name] = r2</span>
            
<span class="c1">#             if r2 &gt; best_score:</span>
<span class="c1">#                 best_score = r2</span>
<span class="c1">#                 best_model = model_name</span>
<span class="c1">#                 best_fit = fit_model</span>
            
<span class="c1">#             # Plot the model</span>
<span class="c1">#             fit_model.plot(x_max=max(bin_center), ax=ax, label=f&quot;{model_name} (R2: {r2:.5f})&quot;)</span>
<span class="c1">#         except Exception as e:</span>
<span class="c1">#             print(f&quot;Error with model {model_name}: {e}&quot;)</span>
    
<span class="c1">#     ax.legend()</span>
<span class="c1">#     ax.set_title(f&#39;Variogram Models with Fitted Data, Best Model= {best_model}, with score{best_score}&#39;)</span>
<span class="c1">#     if show_plot== True:</span>
<span class="c1">#         plt.show()</span>
<span class="c1">#     else:</span>
<span class="c1">#         plt.close()</span>
<span class="c1">#     return best_model, best_score, scores, best_fit</span>
<span class="c1"># def interpolate_kriging_nans_geodataframe(data, threshold=None, variogram_model=None, </span>
<span class="c1"># out_fileName=None, plot=False, Total_days=None, VEL_scale=None, VEL_Mode=None):</span>
    
<span class="c1">#     if isinstance(data, str):</span>
<span class="c1">#         if data[-4:] == &#39;.shp&#39;:</span>
<span class="c1">#             gdf = gpd.read_file(data)</span>

<span class="c1">#             geom=gdf[&#39;geometry&#39;]</span>
<span class="c1">#             crs_ini=gdf.crs</span>
           
<span class="c1">#             out_fileName = data</span>
<span class="c1">#             Total_days=Total_days</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise ValueError(&quot;Unsupported file format.&quot;)</span>
<span class="c1">#     elif isinstance(data, gpd.GeoDataFrame):</span>
<span class="c1">#         gdf = data</span>
<span class="c1">#         out_fileName = None</span>
<span class="c1">#     else:</span>
<span class="c1">#         raise ValueError(&quot;Unsupported data type.&quot;)</span>

<span class="c1">#     unwanted_cols = [&#39;CODE&#39;,&#39;geometry&#39;, &#39;x&#39;, &#39;y&#39;, &#39;VEL&#39;, &#39;VEL_STD&#39;]</span>
<span class="c1">#     columns_to_interpolate = [col for col in gdf.columns if col not in unwanted_cols]</span>


<span class="c1">#     for col in columns_to_interpolate:</span>
<span class="c1">#         if threshold is not None:</span>
<span class="c1">#             gdf = replace_outliers_with_nan_zscore(gdf, col, threshold)</span>
<span class="c1">#         try:</span>
<span class="c1">#             known_data = gdf[~gdf[col].isna()]</span>
<span class="c1">#             unknown_data = gdf[gdf[col].isna()]</span>

<span class="c1">#             known_coords = [(geom.x, geom.y) for geom in known_data.geometry]</span>
<span class="c1">#             unknown_coords = [(geom.x, geom.y) for geom in unknown_data.geometry]</span>


<span class="c1">#             #known_coords = list(known_data.geometry.apply(lambda geom: (geom.x, geom.y)))</span>
<span class="c1">#             known_values =  [x for x in known_data[col]]</span>

<span class="c1">#             #unknown_coords = list(unknown_data.geometry.apply(lambda geom: (geom.x, geom.y)))</span>
<span class="c1">#             if variogram_model is None:</span>
<span class="c1">#                 best_model, best_score, scores, best_fit=fit_variogram_models(gdf.x, gdf.y, gdf[col], latlon=False, show_plot=plot)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 best_fit=variogram_model</span>
<span class="c1">#             ok = OrdinaryKriging(</span>
<span class="c1">#                 [coord[0] for coord in known_coords],</span>
<span class="c1">#                 [coord[1] for coord in known_coords],</span>
<span class="c1">#                 known_values,</span>
<span class="c1">#                 variogram_model=best_fit,</span>
<span class="c1">#                 verbose=False</span>
<span class="c1">#             )</span>

<span class="c1">#             interpolated_values, _ = ok.execute(</span>
<span class="c1">#                 &#39;points&#39;,</span>
<span class="c1">#                 [coord[0] for coord in unknown_coords],</span>
<span class="c1">#                 [coord[1] for coord in unknown_coords]</span>
<span class="c1">#             )</span>

<span class="c1">#             gdf.loc[unknown_data.index, col] = interpolated_values</span>
<span class="c1">#         except Exception as e:</span>
<span class="c1">#             print(f&quot;Error with kriging interpolation: {e}, interpolation performed using pandas interpolation&quot;)</span>
        
<span class="c1">#         gdf[col]=gdf[col].interpolate()</span>
<span class="c1">#     # Interpolating NaN values in the subset DataFrame</span>
<span class="c1">#     gdf[columns_to_interpolate] = gdf[columns_to_interpolate].interpolate(axis=1, limit_direction=&#39;both&#39;)</span>
        
<span class="c1">#     zcol=columns_to_interpolate[0]</span>
<span class="c1">#     #zcol=[gdf[z] for z in columns_to_interpolate]</span>
<span class="c1">#     ######################</span>
<span class="c1">#     if isinstance(data, str):</span>
<span class="c1">#         if data[-4:] == &#39;.shp&#39;:</span>
<span class="c1">#             # Reset the index and convert it to a column</span>
<span class="c1">#             gdf = gdf.reset_index()</span>

<span class="c1">#             # Rename the index column to &quot;CODE&quot;</span>
<span class="c1">#             gdf.rename(columns={&#39;index&#39;: &#39;CODE&#39;}, inplace=True)</span>

            

<span class="c1">#             if VEL_Mode==&#39;linear&#39; and VEL_scale==&#39;year&#39;:</span>
<span class="c1">#                 VEL, VEL_STD=linear_VEL(gdf[columns_to_interpolate], columns_to_interpolate)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL&#39;]= gdf[&#39;VEL&#39;]/ Total_days * 365</span>
            
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 365</span>

<span class="c1">#             if VEL_Mode==&#39;mean&#39; and VEL_scale==&#39;year&#39;:</span>
<span class="c1">#                 VEL=gdf[columns_to_interpolate].mean(axis=1)</span>
<span class="c1">#                 VEL_STD=gdf[columns_to_interpolate].std(axis=1)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;]/ Total_days * 365</span>
                
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD</span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;] / Total_days * 365</span>

<span class="c1">#             if VEL_Mode==&#39;linear&#39; and VEL_scale==&#39;month&#39;:</span>
<span class="c1">#                 VEL, VEL_STD=linear_VEL(gdf[columns_to_interpolate], columns_to_interpolate)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;]/ Total_days * 30</span>

<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 30</span>

<span class="c1">#             if VEL_Mode==&#39;mean&#39; and VEL_scale==&#39;month&#39;:</span>
<span class="c1">#                 VEL=gdf[columns_to_interpolate].mean(axis=1)</span>
<span class="c1">#                 VEL_STD=gdf[columns_to_interpolate].std(axis=1)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;] / Total_days * 30</span>

<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 30</span>

<span class="c1">#             if VEL_Mode==&#39;linear&#39; and VEL_scale==None:</span>
<span class="c1">#                 VEL, VEL_STD=linear_VEL(gdf[columns_to_interpolate], columns_to_interpolate)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL </span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD </span>

<span class="c1">#             if VEL_Mode==&#39;mean&#39; and VEL_scale==None:</span>
<span class="c1">#                 VEL=gdf[columns_to_interpolate].mean(axis=1)</span>
<span class="c1">#                 VEL_STD=gdf[columns_to_interpolate].std(axis=1)</span>
<span class="c1">#                 gdf[&#39;VEL&#39;]=VEL</span>
<span class="c1">#                 gdf[&#39;VEL_STD&#39;]=VEL_STD</span>

<span class="c1">#             column_order = columns_to_interpolate  # New columns added at the beginning</span>
<span class="c1">#             # # Insert new columns at the beginning of the list</span>
<span class="c1">#             columns_to_insert = [&#39;CODE&#39;, &#39;x&#39;, &#39;y&#39;, &#39;VEL&#39;, &#39;VEL_STD&#39;]  # Inserted in this order</span>
<span class="c1">#             col_geo=[&#39;geometry&#39;]</span>
<span class="c1">#             column_order= columns_to_insert + columns_to_interpolate+col_geo</span>
<span class="c1">#             gdf=gdf[column_order]</span>
            
<span class="c1">#             # Get the CRS of the GeoDataFrame</span>
<span class="c1">#             gdf.crs=crs_ini</span>

    

<span class="c1">#     if out_fileName is not None:</span>

<span class="c1">#         gdf.to_file(out_fileName)</span>

<span class="c1">#     if plot is not False:</span>

<span class="c1">#         for col in columns_to_interpolate:</span>
<span class="c1">#             fig, axes = plt.subplots(1, 2, figsize=(12, 6))</span>

<span class="c1">#             gdf.plot(ax=axes[0], column=col, cmap=&#39;rainbow&#39;, legend=True, markersize=5)</span>
<span class="c1">#             axes[0].set_title(f&#39;Before Interpolation - {col}&#39;)</span>

<span class="c1">#             gdf.plot(ax=axes[1], column=col, cmap=&#39;rainbow&#39;, legend=True, markersize=5)</span>
<span class="c1">#             axes[1].set_title(f&#39;After Interpolation - {col}&#39;)</span>

<span class="c1">#             plt.tight_layout()</span>
<span class="c1">#             plt.show()</span>

    
<span class="c1">#     return np.array(gdf.x) , np.array(gdf.y) , np.array(gdf[zcol]), gdf</span>
<span class="c1"># # Usage example</span>
<span class="c1"># shapefile_path = &#39;flowx1.shp&#39;</span>
<span class="c1"># x, y, z=interpolate_kriging_nans_geodataframe(shapefile_path=&#39;flowx.shp&#39;, threshold=None, variogram_model=&#39;gaussian&#39;, </span>
<span class="c1"># out_fileName=&#39;flow11&#39;, plot=True)</span>
<span class="c1">###############################################################################################</span>




<span class="c1">######################################</span>

<div class="viewcode-block" id="process_shapefile_with_rasters"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.process_shapefile_with_rasters">[docs]</a><span class="k">def</span> <span class="nf">process_shapefile_with_rasters</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">,</span> <span class="n">rasterfile_paths</span><span class="p">):</span>
    <span class="c1"># Load the shapefile</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>

    <span class="c1"># Process rasterfile paths</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">rasterfile_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterfile_paths</span><span class="p">]</span>
    <span class="n">raster_paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.tif&#39;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span>
    <span class="n">rasterfile_paths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">raster_paths</span><span class="p">]</span>

    <span class="c1"># Load rasters</span>
    <span class="n">rasters</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">rasterfile_paths</span><span class="p">]</span>

    <span class="c1"># Extract &#39;D&#39; columns</span>
    <span class="n">d_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)]</span>

    <span class="c1"># Map rasters to &#39;D&#39; columns</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">band</span><span class="p">)</span> <span class="k">for</span> <span class="n">band</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)}</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">):</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">raster</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">rasters</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of provided rasters or bands does not match the number of &#39;D&#39; columns in the shapefile.&quot;</span><span class="p">)</span>

    <span class="c1"># Sample values for each &#39;D&#39; column</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
        <span class="n">raster</span><span class="p">,</span> <span class="n">band</span> <span class="o">=</span> <span class="n">raster_band_mapping</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">sampled_values</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">sampled_values</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># # # Check for NaN values in &#39;D&#39; columns</span>
    <span class="c1"># all_nan = gdf[d_columns].isna().all(axis=1)</span>
    <span class="c1"># # Drop all rows with any NaN values</span>
    <span class="c1"># gdf.dropna(inplace=True)</span>
    
    <span class="c1"># gdf = gdf.dropna()</span>
    <span class="n">gdf</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;ssim_mean&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;ssim_std&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Drop the columns</span>
    <span class="c1">#gdf = gdf.drop(columns=d_columns)</span>
    

    <span class="c1"># # Correct displacement to a stable point</span>
    <span class="c1"># try:</span>
    <span class="c1">#     #VEL, VEL_STD_series = linear_VEL(gdf[d_columns], d_columns)</span>
    <span class="c1">#     # Calculate mean, ignoring NaN values</span>
    <span class="c1">#     # Calculate mean, ignoring NaN values</span>
    <span class="c1">#     VEL = gdf[d_columns].mean(axis=1)</span>

    <span class="c1">#     # Calculate standard deviation, ignoring NaN values</span>
    <span class="c1">#     VEL_STD_series = gdf[d_columns].std(axis=1)</span>
        
    <span class="c1">#     gdf[&#39;ssim_mean&#39;]=VEL</span>
    <span class="c1">#     gdf[&#39;ssim_std&#39;]=VEL_STD_series</span>
    <span class="c1">#     # Drop the specified columns</span>
    <span class="c1">#     #gdf = gdf.drop(columns=d_columns, errors=&#39;ignore&#39;)</span>
    <span class="c1">#     # VEL_STD_series = pd.Series(VEL_STD_series)</span>
    <span class="c1">#     # min_std_dev = VEL_STD_series.min()</span>
    <span class="c1">#     # filtered_indices = VEL_STD_series[VEL_STD_series == min_std_dev].index</span>
    <span class="c1">#     # avg_velocities = gdf[d_columns].loc[filtered_indices].mean(axis=1)</span>
    <span class="c1">#     # reference_index = avg_velocities.idxmin()</span>
    <span class="c1"># except Exception as e:</span>
    <span class="c1">#     print(&quot;Error in displacement correction:&quot;, e)</span>
        <span class="c1">#reference_index = None</span>

    <span class="k">return</span> <span class="n">gdf</span></div>

<div class="viewcode-block" id="find_best_match"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.find_best_match">[docs]</a><span class="k">def</span> <span class="nf">find_best_match</span><span class="p">(</span><span class="n">gdf</span><span class="p">):</span>
    <span class="c1"># # Check if the dataframe is empty</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Warning: The dataframe is empty. No data to process.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
     <span class="c1"># Diagnostic: Print DataFrame summary</span>
    <span class="c1">#print(&quot;DataFrame Summary:\n&quot;, gdf.describe())</span>
    <span class="c1"># Check for exact match</span>
    <span class="n">min_vel_indices</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span><span class="o">.</span><span class="n">index</span>
    <span class="n">min_vel_std_indices</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span><span class="o">.</span><span class="n">index</span>
    <span class="c1"># max_ssim_mean_indices = gdf[gdf[&#39;ssim_mean&#39;] == gdf[&#39;ssim_mean&#39;].max()].index</span>
    <span class="c1"># min_ssim_std_indices = gdf[gdf[&#39;ssim_std&#39;] == gdf[&#39;ssim_std&#39;].min()].index</span>

    <span class="c1">#intersection_indices = set(min_vel_indices) &amp; set(min_vel_std_indices) &amp; set(max_ssim_mean_indices) &amp; set(min_ssim_std_indices)</span>
    <span class="n">intersection_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">min_vel_indices</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">min_vel_std_indices</span><span class="p">)</span> 

    <span class="k">if</span> <span class="n">intersection_indices</span><span class="p">:</span>
        <span class="n">best_common_index</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">intersection_indices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">best_common_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Calculate score if no exact match</span>
    <span class="c1"># Adjust weights as necessary</span>
    <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="o">+</span>
        <span class="p">(</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">abs</span><span class="p">()</span> <span class="p">)</span>
    
    <span class="c1">#(gdf[&#39;ssim_mean&#39;].max() - gdf[&#39;ssim_mean&#39;]).abs() + (gdf[&#39;ssim_std&#39;] - gdf[&#39;ssim_std&#39;].min()).abs()</span>

     <span class="c1"># Check if &#39;score&#39; column is empty</span>
    <span class="k">if</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error: The score calculation resulted in an empty series.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Find the index with minimum score</span>
    <span class="n">best_match_index</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;score&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">idxmin</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;best match&#39;</span><span class="p">,</span> <span class="n">best_match_index</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">best_match_index</span></div>


<span class="c1">######################################3</span>



<span class="c1">#############################</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>

<div class="viewcode-block" id="calculate_slopes_std_and_residuals"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.calculate_slopes_std_and_residuals">[docs]</a><span class="k">def</span> <span class="nf">calculate_slopes_std_and_residuals</span><span class="p">(</span><span class="n">geodataframe</span><span class="p">):</span>
    <span class="n">L_slopes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">M_slopes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">L_std_devs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">M_std_devs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Extract the date columns (columns starting with &#39;D&#39;)</span>
    <span class="n">date_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)]</span>
    <span class="n">dates</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_datetime</span><span class="p">([</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">date_columns</span><span class="p">],</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;D%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">days_since_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">dates</span> <span class="o">-</span> <span class="n">dates</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">days</span>

    <span class="c1"># Iterate through each row in the GeoDataFrame</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">geodataframe</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">date_columns</span><span class="p">]</span>

        <span class="n">M_slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="n">M_std_devs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># Calculate the slope and intercept using polyfit</span>
        <span class="n">L_slope</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">days_since_start</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">L_slopes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_slope</span><span class="p">)</span>

        <span class="c1"># Predict values using the regression line and calculate residuals</span>
        <span class="n">predicted_values</span> <span class="o">=</span> <span class="n">L_slope</span> <span class="o">*</span> <span class="n">days_since_start</span> <span class="o">+</span> <span class="n">intercept</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="n">values</span> <span class="o">-</span> <span class="n">predicted_values</span>

        <span class="c1"># Calculate the standard deviation of the residuals</span>
        <span class="n">L_std_dev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">residuals</span><span class="p">)</span>
        <span class="n">L_std_devs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">L_std_dev</span><span class="p">)</span>

    <span class="c1"># Add the slopes, intercepts, and standard deviations as new columns</span>
    <span class="n">geodataframe</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_slopes</span>
    <span class="n">geodataframe</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">L_std_devs</span>
    <span class="c1"># geodataframe[&#39;M_VEL&#39;] = M_slopes</span>
    <span class="c1"># geodataframe[&#39;MSTD_VEL&#39;] = M_std_devs</span>

    <span class="c1"># Ensure the returned object is a GeoDataFrame</span>
    <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geodataframe</span><span class="p">)</span></div>



<span class="n">best_match_index</span><span class="o">=</span><span class="kc">None</span>
<div class="viewcode-block" id="update_nodata_values"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.update_nodata_values">[docs]</a><span class="k">def</span> <span class="nf">update_nodata_values</span><span class="p">(</span><span class="n">shapefile_path</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> 
                         <span class="n">rasterfile_paths</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">interpolate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">master_reference</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="k">global</span> <span class="n">best_match_index</span>
    <span class="c1"># Load the shapefile</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>
    <span class="c1">#gdf = gdf.drop(&#39;CODE&#39;)</span>
    <span class="n">crs_ini</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">crs</span>

    <span class="n">raster_folder</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">)</span>
    <span class="n">raster_paths</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">raster_folder</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.tif&#39;</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">stem</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rasterfile_paths</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">rasterfile_paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterfile_paths</span><span class="p">]</span>
        <span class="n">rasterfile_paths</span><span class="o">=</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">raster_paths</span><span class="p">]</span>

    <span class="c1"># Load rasters</span>
    <span class="n">rasters</span> <span class="o">=</span> <span class="p">[</span><span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">rasterfile_paths</span><span class="p">]</span>

    <span class="n">d_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">)]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">:</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">rasters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">band</span><span class="p">)</span> <span class="k">for</span> <span class="n">band</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)}</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rasters</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">):</span>
        <span class="n">raster_band_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="n">raster</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">d_columns</span><span class="p">,</span> <span class="n">rasters</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The number of provided rasters or bands does not match the number of &#39;D&#39; columns in the shapefile.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
        <span class="n">raster</span><span class="p">,</span> <span class="n">band</span> <span class="o">=</span> <span class="n">raster_band_mapping</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        
        <span class="c1"># Extract x, y coordinates for all rows at once</span>
        <span class="n">x_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y_values</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">geom</span><span class="p">:</span> <span class="n">geom</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># Sample all values for the current column at once</span>
        <span class="n">sampled_values</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x_values</span><span class="p">,</span> <span class="n">y_values</span><span class="p">)),</span> <span class="n">indexes</span><span class="o">=</span><span class="n">band</span><span class="p">)</span>
        <span class="c1"># Update the entire column in one go</span>
        <span class="c1">#gdf[col] = [val[0] for val in sampled_values]</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">sampled_values</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    

    <span class="c1"># Check if all cells in d_columns are NaN</span>
    <span class="n">all_nan</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
        <span class="c1"># Interpolate only for rows where all cells in d_columns are not NaN</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">all_nan</span><span class="p">,</span> <span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="o">~</span><span class="n">all_nan</span><span class="p">,</span> <span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">limit_direction</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

    <span class="c1"># Drop rows where all cells in d_columns are NaN</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="o">~</span><span class="n">all_nan</span><span class="p">]</span>
   
    
    <span class="c1"># Check if master_reference is not None before proceeding with the code</span>
    <span class="k">if</span> <span class="n">master_reference</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    
        <span class="c1">#Subtract columns based on master_reference flag</span>
        <span class="k">if</span> <span class="n">master_reference</span><span class="o">==</span><span class="s1">&#39;single&#39;</span><span class="p">:</span> 
            <span class="n">master_col</span> <span class="o">=</span> <span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#cols_without_mastercol=d_columns[1:]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
                <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">master_col</span><span class="p">]</span>
            <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            
        <span class="k">elif</span> <span class="n">master_reference</span><span class="o">==</span><span class="s1">&#39;multiple&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d_columns</span><span class="p">)):</span>
                
                <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Code to handle the case when master_reference is None</span>
          <span class="c1"># You can add appropriate handling here, or leave it empty if you want to skip the code entirely</span>
        <span class="c1">#gdf[d_columns] = gdf[d_columns].cumsum(axis=1)</span>
        <span class="k">pass</span>
       
    <span class="c1"># Set data types: first d_column to int, the rest to float32</span>
    <span class="c1">#gdf[d_columns[0]] = gdf[d_columns[0]].astype(int)</span>
    <span class="c1">#for col in d_columns[1:]:</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">d_columns</span><span class="p">:</span>
        <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">raster</span> <span class="ow">in</span> <span class="n">rasters</span><span class="p">:</span>
        <span class="n">raster</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="c1">########################</span>
    
    <span class="c1">#  # Reset the index and convert it to a column</span>
    <span class="c1"># gdf = gdf.reset_index()</span>

    <span class="c1"># # # Rename the index column to &quot;CODE&quot;</span>
    <span class="c1"># gdf=gdf.rename(columns={&#39;index&#39;: &#39;CODE&#39;})</span>
    <span class="n">gdf</span><span class="o">=</span><span class="n">calculate_slopes_std_and_residuals</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">calculate_VEL</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="n">Total_days</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;year&#39;</span><span class="p">:</span>
            <span class="c1"># VEL, VEL_STD=linear_VEL(gdf[d_columns], d_columns)</span>
            <span class="c1"># gdf[&#39;VEL&#39;]=VEL </span>
            <span class="c1">#gdf[&#39;VEL&#39;]= gdf[&#39;VEL&#39;]/ Total_days * 365</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">*</span>  <span class="mf">365.25</span>
        
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 365</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">Total_days</span> <span class="o">*</span> <span class="mf">365.25</span>
            
            
        
        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;year&#39;</span><span class="p">:</span>
            <span class="n">VEL</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">VEL_STD</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL</span> 
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mf">365.25</span>
            <span class="c1">#gdf[&#39;VEL&#39;]= gdf[&#39;VEL&#39;] * 365.25</span>
        
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL_STD</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mf">365.25</span>
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;] * 365</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;month&#39;</span><span class="p">:</span>
            <span class="c1"># VEL, VEL_STD=linear_VEL(gdf[d_columns], d_columns)</span>
            <span class="c1"># gdf[&#39;VEL&#39;]=VEL </span>
            <span class="c1">#gdf[&#39;VEL&#39;]=gdf[&#39;VEL&#39;]/ Total_days * 30</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">30</span>

            <span class="c1">#gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
            <span class="c1">#gdf[&#39;VEL_STD&#39;]=gdf[&#39;VEL_STD&#39;]/ Total_days * 30</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">Total_days</span> <span class="o">*</span> <span class="mi">30</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="s1">&#39;month&#39;</span><span class="p">:</span>
            <span class="n">VEL</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">VEL_STD</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mi">30</span>

            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL_STD</span> 
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">/</span> <span class="n">Total_days</span> <span class="o">*</span> <span class="mi">30</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="c1"># VEL, VEL_STD=linear_VEL(gdf[d_columns], d_columns)</span>
            <span class="c1"># gdf[&#39;VEL&#39;]=VEL </span>
            <span class="c1"># gdf[&#39;VEL_STD&#39;]=VEL_STD </span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">VEL_Mode</span><span class="o">==</span><span class="s1">&#39;mean&#39;</span> <span class="ow">and</span> <span class="n">VEL_scale</span><span class="o">==</span><span class="kc">None</span><span class="p">:</span>
            <span class="n">VEL</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">VEL_STD</span><span class="o">=</span><span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL</span>
            <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">VEL_STD</span>
        <span class="k">return</span> <span class="n">gdf</span>

    <span class="n">gdf</span><span class="o">=</span><span class="n">calculate_VEL</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="n">Total_days</span><span class="p">)</span>
    <span class="c1"># column_order = d_columns  # New columns added at the beginning</span>
    <span class="c1"># # # Insert new columns at the beginning of the list</span>
    <span class="c1"># columns_to_insert = [&#39;CODE&#39;, &#39;x&#39;, &#39;y&#39;, &#39;VEL&#39;, &#39;VEL_STD&#39;]  # Inserted in this order</span>
    <span class="c1"># col_geo=[&#39;geometry&#39;]</span>
    <span class="c1"># column_order= columns_to_insert + d_columns+col_geo</span>
    <span class="c1"># gdf=gdf[column_order]</span>
    
    <span class="c1">########</span>
    <span class="c1"># Extracting x and y coordinates from the &#39;geometry&#39; column</span>
    <span class="c1"># gdf[&#39;x&#39;] = gdf.apply(lambda row: row.geometry.x, axis=1)</span>
    <span class="c1"># gdf[&#39;y&#39;] = gdf.apply(lambda row: row.geometry.y, axis=1)</span>
    <span class="n">col_titles</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;VEL&#39;</span><span class="p">,</span> <span class="s1">&#39;VEL_STD&#39;</span> <span class="p">]</span><span class="o">+</span><span class="n">d_columns</span>
    <span class="c1"># Reset the index and convert it to a column</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Rename the index column to &quot;CODE&quot;</span>
    <span class="c1">#gdf = gdf.rename(columns={&#39;index&#39;: &#39;CODE&#39;})</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">col_titles</span><span class="p">)</span>
    
    <span class="c1"># Get the CRS of the GeoDataFrame</span>
    <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">crs_ini</span>
    <span class="c1">#gdf=gdf.dropna()</span>
    <span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
    
    <span class="c1">#####Correct displacement to a stable point############</span>
    <span class="c1"># try:</span>
    <span class="c1">#     # _, VEL_STD_series = linear_VEL(gdf[d_columns], d_columns)</span>
        
    <span class="c1">#     # # Filter points with the lowest standard deviation</span>
    <span class="c1">#     # VEL_STD_series = pd.Series(VEL_STD_series)</span>
    <span class="c1">#     # min_std_dev = VEL_STD_series.min()</span>
    <span class="c1">#     # filtered_indices = VEL_STD_series[VEL_STD_series == min_std_dev].index</span>
        
    <span class="c1">#     # # From the filtered points, select the point with the lowest average velocity</span>
    <span class="c1">#     # avg_velocities = gdf[d_columns].loc[filtered_indices].mean(axis=1)</span>
    <span class="c1">#     # reference_index = avg_velocities.idxmin()</span>
    <span class="k">try</span><span class="p">:</span> 
        
        
        <span class="k">if</span> <span class="n">best_match_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">best_match_index</span><span class="o">=</span><span class="n">find_best_match</span><span class="p">(</span><span class="n">gdf</span><span class="p">)</span>
        
        <span class="c1"># # Compare each geometry in the GeoDataFrame with the target geometry</span>
        <span class="c1"># for best_match_index, row in gdf.iterrows():</span>
        <span class="c1">#     if row[&#39;geometry&#39;] == geometry_point:</span>
        <span class="c1">#         return best_match_index</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="n">best_match_index</span><span class="p">)</span>
        
        
        <span class="kn">import</span> <span class="nn">shutil</span>
        <span class="c1"># # Create the subdirectory again</span>
        <span class="c1"># os.makedirs(sub_dir_path, exist_ok=True)</span>
        <span class="n">folder_directory</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>
        <span class="n">base_filename</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">shapefile_path</span><span class="p">)</span>
        <span class="n">updated_dir</span><span class="o">=</span><span class="n">folder_directory</span><span class="o">+</span> <span class="s2">&quot;/&quot;</span><span class="o">+</span> <span class="s2">&quot;updated_shapefiles&quot;</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">updated_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> 
        
        <span class="c1">#   # Check if the subdirectory exists</span>
        <span class="c1"># if os.path.exists(folder_directory):</span>
        <span class="c1">#     # Remove the existing subdirectory</span>
        <span class="c1">#     shutil.rmtree(folder_directory)</span>
        


        <span class="c1">#####################</span>
        <span class="c1"># Save the updated and interpolated GeodataFrame to a new shapefile or return it</span>
        <span class="n">updated_shapefile_path</span> <span class="o">=</span> <span class="n">updated_dir</span><span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="n">base_filename</span>
        <span class="n">gdf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">updated_shapefile_path</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="s1">&#39;ESRI Shapefile&#39;</span><span class="p">)</span>
        
        <span class="c1"># Correct the velocity of each month based on the reference point</span>
        <span class="k">if</span> <span class="n">best_match_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">[</span><span class="n">d_columns</span><span class="p">]:</span>
                <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">]</span>

            <span class="c1"># Extract x, y values of the reference point</span>
            <span class="c1"># ref_point = gdf.geometry.iloc[best_match_index]</span>
            <span class="c1"># ref_point=ref_point</span>
            <span class="c1"># x, y = ref_point.x , ref_point.y</span>
            <span class="n">x</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">]</span>
            <span class="n">y</span><span class="o">=</span><span class="n">gdf</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">]</span>
            <span class="n">VEL_ref</span><span class="p">,</span> <span class="n">VEL_ref_STD</span><span class="o">=</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">VEL</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">],</span> <span class="n">gdf</span><span class="o">.</span><span class="n">VEL_STD</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">best_match_index</span><span class="p">])</span>
            
            <span class="n">dic_data</span><span class="o">=</span><span class="p">{</span>
                        <span class="s2">&quot;ReferencePoint&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;Coordinates&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)},</span> <span class="s2">&quot;VELDATA&quot;</span><span class="p">:{</span> <span class="s2">&quot;VEL&quot;</span><span class="p">:</span> <span class="n">VEL_ref</span><span class="p">,</span> <span class="s2">&quot;VEL_STD&quot;</span><span class="p">:</span> <span class="n">VEL_ref_STD</span><span class="p">}}</span>
            
            <span class="k">def</span> <span class="nf">dict_to_xml</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="kn">from</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">import</span> <span class="n">Element</span><span class="p">,</span> <span class="n">SubElement</span><span class="p">,</span> <span class="n">tostring</span>
                <span class="kn">from</span> <span class="nn">xml.dom</span> <span class="kn">import</span> <span class="n">minidom</span>
                <span class="n">root</span> <span class="o">=</span> <span class="n">Element</span><span class="p">(</span><span class="s1">&#39;Data&#39;</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">inner_key</span><span class="p">,</span> <span class="n">inner_value</span> <span class="ow">in</span> <span class="n">value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inner_value</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                            <span class="n">coord</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">inner_key</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">coord_key</span><span class="p">,</span> <span class="n">coord_value</span> <span class="ow">in</span> <span class="n">inner_value</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                                <span class="n">coord_element</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">coord_key</span><span class="p">)</span>
                                <span class="n">coord_element</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">coord_value</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">element</span> <span class="o">=</span> <span class="n">SubElement</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">inner_key</span><span class="p">)</span>
                            <span class="n">element</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">inner_value</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">minidom</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">))</span><span class="o">.</span><span class="n">toprettyxml</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="s2">&quot;   &quot;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>
            <span class="n">xml_name</span><span class="o">=</span><span class="n">updated_shapefile_path</span> <span class="o">+</span> <span class="s2">&quot;.xml&quot;</span>
            <span class="c1"># Using the function to write the dictionary to an XML file</span>
            <span class="n">xml_data</span> <span class="o">=</span><span class="n">dict_to_xml</span><span class="p">(</span><span class="n">dic_data</span><span class="p">)</span>
            <span class="n">xml_data_str</span> <span class="o">=</span> <span class="n">xml_data</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;UTF-8&#39;</span><span class="p">)</span>
            
            <span class="c1"># Saving the XML to a file</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">xml_name</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span> <span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">xml_data_str</span><span class="p">)</span>
            
            <span class="c1"># Create an XML with x, y values</span>
            <span class="c1"># metadata = ET.Element(&quot;Metadata&quot;)</span>
            <span class="c1"># ref_point_elem = ET.SubElement(metadata, &quot;ReferencePoint&quot;)</span>
            <span class="c1"># x_elem = ET.SubElement(ref_point_elem, &quot;x&quot;)</span>
            <span class="c1"># x_elem.text = str(x)</span>
            <span class="c1"># y_elem = ET.SubElement(ref_point_elem, &quot;y&quot;)</span>
            <span class="c1"># y_elem.text = str(y)</span>
            <span class="c1"># Creating the XML structure</span>
            <span class="c1"># metadata = ET.Element(&quot;Metadata&quot;)</span>
            <span class="c1"># ref_point_elem = ET.SubElement(metadata, &quot;ReferencePoint&quot;)</span>
            <span class="c1"># x_elem = ET.SubElement(ref_point_elem, &quot;x&quot;)</span>
            <span class="c1"># #x_elem.text = str(x)</span>
            <span class="c1"># x_elem.set(&#39;value&#39;, str(x))  # Setting the &#39;value&#39; attribute</span>
            <span class="c1"># y_elem = ET.SubElement(ref_point_elem, &quot;y&quot;)</span>
            <span class="c1"># #y_elem.text = str(y)</span>
            <span class="c1"># y_elem.set(&#39;value&#39;, str(y))  # Setting the &#39;value&#39; attribute</span>

            
            <span class="c1"># # Write the XML to a file</span>
            <span class="c1"># tree = ET.ElementTree(metadata)</span>
            <span class="c1"># tree.write(updated_shapefile_path + &quot;.xml&quot;)</span>
            
            <span class="c1"># with open(shapefile_path + &quot;.xml&quot;, &quot;wb&quot;) as file:</span>
            <span class="c1">#     tree.write(file, encoding=&#39;utf-8&#39;, xml_declaration=True)</span>
            
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;ReferencePoint x, y: </span><span class="si">{</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="si">}</span><span class="s1">, VEL, VEL_STD: </span><span class="si">{</span><span class="w"> </span><span class="n">VEL_ref</span><span class="p">,</span><span class="w"> </span><span class="n">VEL_ref_STD</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    
    <span class="n">update_dir_shapefile</span><span class="o">=</span><span class="n">updated_shapefile_path</span>
   
    
    
    <span class="c1"># with open(updated_shapefile_path[:-4] + &quot;.cpg&quot;, &quot;w&quot;) as f:</span>
    <span class="c1">#     f.write(&quot;UTF-8&quot;)</span>
    <span class="k">return</span> <span class="n">gdf</span> <span class="p">,</span> <span class="n">update_dir_shapefile</span></div>

<span class="c1">##################################################################################################</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">Point</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<div class="viewcode-block" id="merge_geodataframes_generator"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.merge_geodataframes_generator">[docs]</a><span class="k">def</span> <span class="nf">merge_geodataframes_generator</span><span class="p">(</span><span class="n">gdfs</span><span class="p">):</span>
    <span class="n">total_gdfs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gdfs</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">gdf</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gdfs</span><span class="p">):</span>
        <span class="c1"># Extracting x, y coordinates from the geometry on-the-fly without adding to the dataframe</span>
        <span class="c1"># xy = gdf.geometry.apply(lambda geom: (geom.x, geom.y))</span>
        <span class="c1"># gdf[&#39;x&#39;], gdf[&#39;y&#39;] = zip(*xy)</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span>
        <span class="n">gdf</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># Drop the &#39;geometry&#39; column</span>
        <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">gdf</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

        <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Merging GeoDataFrame </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">total_gdfs</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">yield</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">description</span></div>



    <span class="c1"># Correcting the date format in column names and filtering columns</span>
<span class="k">def</span> <span class="nf">correct_date_format</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">):</span>
        <span class="n">date_part</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if the date part is in valid date format</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_part</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">col</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If not, return None to indicate an invalid date format</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return non-date columns as is</span>
        <span class="k">return</span> <span class="n">col</span>


<div class="viewcode-block" id="merge_geodataframes"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.merge_geodataframes">[docs]</a><span class="k">def</span> <span class="nf">merge_geodataframes</span><span class="p">(</span><span class="n">gdfs</span><span class="p">):</span>
    <span class="c1">############3</span>
    
    <span class="c1">################</span>
    <span class="n">gdf_gen</span> <span class="o">=</span> <span class="n">merge_geodataframes_generator</span><span class="p">(</span><span class="n">gdfs</span><span class="p">)</span>
    
    <span class="c1"># Instead of merging iteratively, collect all dataframes and concatenate at once</span>
    <span class="n">dfs_to_merge</span> <span class="o">=</span> <span class="p">[</span><span class="n">gdf</span> <span class="k">for</span> <span class="n">gdf</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">gdf_gen</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">gdfs</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Preparing GeoDataFrames&quot;</span><span class="p">)]</span>

    <span class="c1"># Concatenate all dataframes</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs_to_merge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Drop duplicates based on x, y</span>
    <span class="n">merged_df</span> <span class="o">=</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">])</span>

    <span class="c1"># Create the final GeoDataFrame with one geometry column</span>
    <span class="n">geometry</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="k">for</span> <span class="n">xy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">merged_df</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">merged_df</span><span class="o">.</span><span class="n">y</span><span class="p">)]</span>
    <span class="n">final_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
    
    
    <span class="k">return</span> <span class="n">final_gdf</span></div>


<span class="c1">###################################################################</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">listdir</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isfile</span><span class="p">,</span> <span class="n">join</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_pdf</span> <span class="kn">import</span> <span class="n">PdfPages</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1.inset_locator</span> <span class="kn">import</span> <span class="n">inset_axes</span>
<span class="kn">from</span> <span class="nn">rasterio.features</span> <span class="kn">import</span> <span class="n">geometry_mask</span>
<span class="kn">from</span> <span class="nn">rasterio.transform</span> <span class="kn">import</span> <span class="n">from_origin</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
<span class="kn">from</span> <span class="nn">skimage.metrics</span> <span class="kn">import</span> <span class="n">structural_similarity</span> <span class="k">as</span> <span class="n">ssim</span>


<div class="viewcode-block" id="mask_raster"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.mask_raster">[docs]</a><span class="k">def</span> <span class="nf">mask_raster</span><span class="p">(</span><span class="n">dem_array</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">no_data_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">scatter_x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scatter_y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        - Mask a given raster (DEM) array using a binary mask and optionally filter scatter plot data based on the same mask.</span>
<span class="sd">        - dem_array (np.ndarray, optional): The 2D or 3D input raster array to be masked. If 3D, the last dimension is assumed to be the channel dimension (e.g., RGB).</span>
<span class="sd">        - mask_path (str): The path to the raster file containing the binary mask. Values of 1 in the mask represent areas to keep, and values of 0 represent areas to mask out.</span>
<span class="sd">        - no_data_value (scalar, optional): The value to replace the masked regions with in the `dem_array`. Defaults to np.nan.</span>
<span class="sd">        - scatter_x (np.ndarray, optional): The x-coordinates of scatter plot data to be filtered based on the mask. If provided, `scatter_y` must also be provided.</span>
<span class="sd">        - scatter_y (np.ndarray, optional): The y-coordinates of scatter plot data to be filtered based on the mask. If provided, `scatter_x` must also be provided.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        - np.ndarray: The masked raster array. This array will be of the same shape and data type as the input `dem_array`.</span>
<span class="sd">        - (If scatter_x and scatter_y are provided)</span>
<span class="sd">        - np.ndarray: The x-coordinates of the scatter plot data after filtering with the mask.</span>
<span class="sd">        - np.ndarray: The y-coordinates of the scatter plot data after filtering with the mask.</span>

<span class="sd">    Note:</span>
<span class="sd">        If the `dem_array` data type is integer and the `no_data_value` is np.nan, the function will </span>
<span class="sd">        replace NaN values with a default &quot;no data&quot; integer value (-9999) before casting back to the </span>
<span class="sd">        original data type.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">zoom</span>

    <span class="c1"># Read the binary mask</span>
    <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">mask_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">mask_src</span><span class="p">:</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">mask_src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># If the shapes don&#39;t match and dem_array is provided, resize mask_array</span>
    <span class="k">if</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
        <span class="n">y_scale</span> <span class="o">=</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_scale</span> <span class="o">=</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">mask_array</span><span class="p">,</span> <span class="p">(</span><span class="n">y_scale</span><span class="p">,</span> <span class="n">x_scale</span><span class="p">))</span>

    <span class="c1">#################3Threshold mask_array</span>
    <span class="n">mask_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_array</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Check if scatter_x and scatter_y are provided</span>
    <span class="n">scatter_x_masked</span><span class="p">,</span> <span class="n">scatter_y_masked</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">scatter_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scatter_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">scatter_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scatter_x</span><span class="p">)</span>
        <span class="n">scatter_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scatter_y</span><span class="p">)</span>
        <span class="c1"># Ensure scatter coordinates are within the bounds of the mask_array</span>
        <span class="n">scatter_x_clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">scatter_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">scatter_y_clipped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">scatter_y</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="n">valid_indices</span> <span class="o">=</span> <span class="n">mask_array</span><span class="p">[</span><span class="n">scatter_y_clipped</span><span class="p">,</span> <span class="n">scatter_x_clipped</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="n">scatter_x_masked</span> <span class="o">=</span> <span class="n">scatter_x</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>
        <span class="n">scatter_y_masked</span> <span class="o">=</span> <span class="n">scatter_y</span><span class="p">[</span><span class="n">valid_indices</span><span class="p">]</span>

    <span class="c1"># If dem_array is provided, mask it</span>
    <span class="n">masked_array</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_array</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dem_array</span><span class="p">,</span> <span class="n">no_data_value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_array</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dem_array</span><span class="p">,</span> <span class="n">no_data_value</span><span class="p">)</span>

        <span class="c1"># Handle casting to original data type</span>
        <span class="n">original_dtype</span> <span class="o">=</span> <span class="n">dem_array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">original_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">int_no_data</span> <span class="o">=</span> <span class="o">-</span><span class="mi">9999</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">masked_array</span><span class="p">),</span> <span class="n">int_no_data</span><span class="p">,</span> <span class="n">masked_array</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">original_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">masked_array</span> <span class="o">=</span> <span class="n">masked_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">original_dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scatter_x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">scatter_y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">,</span> <span class="n">scatter_x_masked</span><span class="p">,</span> <span class="n">scatter_y_masked</span>
    <span class="k">elif</span> <span class="n">dem_array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">scatter_x_masked</span><span class="p">,</span> <span class="n">scatter_y_masked</span></div>


<span class="c1"># Correcting the date format in column names and filtering columns</span>
<div class="viewcode-block" id="correct_date_format"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.correct_date_format">[docs]</a><span class="k">def</span> <span class="nf">correct_date_format</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">):</span>
        <span class="n">date_part</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if the date part is in valid date format</span>
            <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_part</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">col</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># If not, return None to indicate an invalid date format</span>
            <span class="k">return</span> <span class="kc">None</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Return non-date columns as is</span>
        <span class="k">return</span> <span class="n">col</span></div>

<div class="viewcode-block" id="Optical_flow_akhdefo"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.Optical_flow_akhdefo">[docs]</a><span class="k">def</span> <span class="nf">Optical_flow_akhdefo</span><span class="p">(</span><span class="n">input_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">AOI</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="mi">2</span> <span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">image_resolution</span><span class="o">=</span><span class="s1">&#39;3125mm&#39;</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">point_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                          <span class="n">dem_path</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="s1">&#39;year&#39;</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                            <span class="n">good_match_option</span><span class="o">=</span><span class="mf">0.75</span><span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">shapefile_output</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_triplet_interval</span><span class="o">=</span><span class="mi">24</span><span class="p">,</span>
                            <span class="n">pixel_size</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="mi">0</span> <span class="p">,</span> <span class="n">pyr_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> 
                            <span class="n">master_reference</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">,</span> <span class="n">selection_Mode</span><span class="o">=</span><span class="s1">&#39;triplet&#39;</span> <span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">   </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs feature matching and velocity/displacement calculations across a series of images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input_dir: str</span>
<span class="sd">        Path to the directory where the input images are stored.</span>

<span class="sd">    output_dir : str</span>
<span class="sd">        Path to the directory where the output files will be saved.</span>

<span class="sd">    AOI : str</span>
<span class="sd">        The shapefile that represents the Area of Interest (AOI).</span>

<span class="sd">    zscore_threshold : float</span>
<span class="sd">        The threshold value used to filter matches based on their Z-score.</span>

<span class="sd">    image_resolution : str</span>
<span class="sd">        The resolution of the images specified per pixel. This can be expressed in various units </span>
<span class="sd">        like &#39;3125mm&#39;, &#39;3.125m&#39; or &#39;3.125meter&#39;.</span>

<span class="sd">    VEL_scale: (str, optional)</span>
<span class="sd">        options year, month, None , default year</span>
<span class="sd">    </span>
<span class="sd">    VEL_Mode: str</span>
<span class="sd">        Options linear or mean , default linear</span>

<span class="sd">    good_match_option: float</span>
<span class="sd">        ratio test as per Lowe&#39;s paper default 0.75</span>

<span class="sd">    shapefile_output: bool</span>
<span class="sd">        True to export timeseries as deformation products as shapefile, default False</span>
<span class="sd">    </span>
<span class="sd">    max_triplet_interval: int </span>
<span class="sd">        Maximum interval days between images allowed to form triplets</span>
<span class="sd">        </span>
<span class="sd">    master_reference: str </span>
<span class="sd">        single, multiple, None</span>
<span class="sd">        </span>
<span class="sd">    Vegetation_mask: (str, optional)</span>
<span class="sd">        Path to a raster file that represents a vegetation mask. Pixels in the input image</span>
<span class="sd">        that correspond to non-vegetation in the mask will be set to one.</span>
<span class="sd">    </span>
<span class="sd">    pyr_scale: float</span>
<span class="sd">        parameter, specifying the image scale (&lt;1) to build pyramids for each image; pyr_scale=0.5 means a classical pyramid, where each next layer is twice smaller than the previous one.</span>
<span class="sd">    levels: int</span>
<span class="sd">        number of pyramid layers including the initial image; levels=1 means that no extra layers are created and only the original images are used.</span>
<span class="sd">    winsize: int</span>
<span class="sd">        averaging window size; larger values increase the algorithm robustness to image noise and give more chances for fast motion detection, but yield more blurred motion field.</span>
<span class="sd">    iterations: int</span>
<span class="sd">        number of iterations the algorithm does at each pyramid level.</span>
<span class="sd">    poly_n: int</span>
<span class="sd">        size of the pixel neighborhood used to find polynomial expansion in each pixel; </span>
<span class="sd">        larger values mean that the image will be approximated with smoother surfaces, </span>
<span class="sd">        yielding more robust algorithm and more blurred motion field, typically poly_n =5 or 7.</span>
<span class="sd">        </span>
<span class="sd">    poly_sigma: float</span>
<span class="sd">        standard deviation of the Gaussian that is used to smooth derivatives used as a basis for the polynomial expansion; </span>
<span class="sd">        for poly_n=5, you can set poly_sigma=1.1, for poly_n=7, a good value would be poly_sigma=1.5.</span>
<span class="sd">    flags: 0 or 1</span>
<span class="sd">        operation flags that can be a combination of the following:</span>
<span class="sd">        0 OPTFLOW_USE_INITIAL_FLOW uses the input flow as an initial flow approximation.</span>
<span class="sd">        1 OPTFLOW_FARNEBACK_GAUSSIAN uses the Gaussian winsize×winsize filter instead of a box filter of the same size for optical flow estimation; </span>
<span class="sd">        usually, this option gives z more accurate flow than with a box filter, at the cost of lower speed; </span>
<span class="sd">        normally, winsize for a Gaussian window should be set to a larger value to achieve the same level of robustness.</span>
<span class="sd">    </span>
<span class="sd">    start_date : str (example 20210203)</span>
<span class="sd">        The start date of the image series.</span>

<span class="sd">    end_date : str (example 20210503)</span>
<span class="sd">        The end date of the image series.   </span>
<span class="sd">    </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    image1 : numpy.ndarray</span>
<span class="sd">        The first image in the series.</span>

<span class="sd">    image3 : numpy.ndarray</span>
<span class="sd">        The third image in the series.</span>

<span class="sd">    mean_vel_list : list</span>
<span class="sd">        A list of mean velocity arrays, each array corresponding to a pair of images.</span>

<span class="sd">    mean_flowx_list : list</span>
<span class="sd">        A list of mean x-flow arrays, each array corresponding to a pair of images.</span>

<span class="sd">    mean_flowy_list : list</span>
<span class="sd">        A list of mean y-flow arrays, each array corresponding to a pair of images.</span>

<span class="sd">    points1_i : numpy.ndarray</span>
<span class="sd">        Array of keypoints for the first image in the last pair.</span>

<span class="sd">    points2 : numpy.ndarray</span>
<span class="sd">        Array of keypoints for the second image in the last pair.</span>

<span class="sd">    &quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="nf">detect_keypoints</span><span class="p">(</span><span class="n">image</span><span class="p">):</span>
        <span class="n">sift</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">SIFT_create</span><span class="p">()</span>
        <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span> <span class="o">=</span> <span class="n">sift</span><span class="o">.</span><span class="n">detectAndCompute</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span>


    <span class="k">def</span> <span class="nf">compare_images</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">):</span>
        <span class="c1"># Rasterio reads data as (bands, height, width)</span>
        <span class="c1"># OpenCV expects data as (height, width, channels)</span>
        <span class="c1"># So we need to transpose the data</span>
        <span class="c1"># image1 = np.transpose(image1, [1, 2, 0])</span>
        <span class="c1"># image2 = np.transpose(image2, [1, 2, 0])</span>
        <span class="c1"># Convert the images to grayscale</span>
        <span class="k">if</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">image1</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">image2</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>
        <span class="c1"># image1_gray = cv2.cvtColor(image1, cv2.COLOR_BGR2GRAY)</span>
        <span class="c1"># image2_gray = cv2.cvtColor(image2, cv2.COLOR_BGR2GRAY)</span>
        <span class="c1"># Calculate SSIM</span>
       
        <span class="n">mask1</span><span class="o">=</span><span class="n">gray1</span><span class="p">[</span><span class="n">gray1</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">mask2</span><span class="o">=</span><span class="n">gray2</span><span class="p">[</span><span class="n">gray2</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">ssim_index</span><span class="p">,</span> <span class="n">ssim_map</span> <span class="o">=</span> <span class="n">ssim</span><span class="p">(</span><span class="n">gray1</span><span class="p">,</span> <span class="n">gray2</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">ssim_map</span><span class="p">[</span><span class="n">mask1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">ssim_map</span><span class="p">[</span><span class="n">mask2</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">ssim_map</span><span class="p">[</span><span class="n">ssim_map</span><span class="o">&gt;</span><span class="mf">0.95</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="c1"># Compute the structural similarity index (SSIM) between the two images</span>
        <span class="k">return</span> <span class="n">ssim_map</span>


    <span class="k">def</span> <span class="nf">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">descriptor1</span><span class="p">,</span> <span class="n">descriptor2</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">good_match_option</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">good_matches</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Initialize an empty list for good_matches</span>
    
        <span class="n">bf</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">BFMatcher</span><span class="p">()</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="n">bf</span><span class="o">.</span><span class="n">knnMatch</span><span class="p">(</span><span class="n">descriptor1</span><span class="p">,</span> <span class="n">descriptor2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Calculate distances for all matches</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">]</span>
        
        <span class="c1"># Calculate mean and standard deviation of distances</span>
        <span class="n">mean_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        <span class="n">std_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        
        <span class="c1"># Define a threshold based on the Z-score</span>
        <span class="n">z_score_threshold</span> <span class="o">=</span> <span class="n">zscore_threshold</span>

        <span class="c1">#mean_distance + z_score_threshold * std_distance</span>
        
        <span class="c1"># Filter matches based on the Z-score</span>
        <span class="k">if</span> <span class="n">good_match_option</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">good_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">good_match_option</span> <span class="o">*</span> <span class="n">n</span><span class="o">.</span><span class="n">distance</span><span class="p">]</span>


        <span class="k">else</span><span class="p">:</span>

            <span class="n">good_matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span> <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">matches</span> <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">distance</span> <span class="o">&lt;</span> <span class="n">mean_distance</span> <span class="o">+</span> <span class="n">z_score_threshold</span> <span class="o">*</span> <span class="n">std_distance</span><span class="p">]</span>

    
        <span class="k">return</span> <span class="n">good_matches</span>

    <span class="kn">import</span> <span class="nn">cv2</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span>
    <span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">gaussian</span>

    <span class="k">def</span> <span class="nf">calculate_optical_flow</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">,</span> <span class="n">pyr_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Rasterio reads data as (bands, height, width)</span>
        <span class="c1"># OpenCV expects data as (height, width, channels)</span>
        <span class="c1"># So we need to transpose the data</span>
        <span class="c1"># image1 = np.transpose(image1, [1, 2, 0])</span>
        <span class="c1"># image2 = np.transpose(image2, [1, 2, 0])</span>
        
        <span class="c1"># Convert the images to grayscale</span>

        <span class="k">if</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">image1</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray1</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">image2</span><span class="p">[:,:,</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Take only the first channel</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gray2</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cvtColor</span><span class="p">(</span><span class="n">image2</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">COLOR_BGR2GRAY</span><span class="p">)</span>

        <span class="c1"># Confirm that gray1 and gray2 are both 2D (grayscale) images of the same size</span>
        <span class="k">assert</span> <span class="n">gray1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;gray1 is not a grayscale image&quot;</span>
        <span class="k">assert</span> <span class="n">gray2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;gray2 is not a grayscale image&quot;</span>
        <span class="k">assert</span> <span class="n">gray1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">gray2</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;gray1 and gray2 are not the same size&quot;</span>
        
        <span class="c1"># Calculate optical flow</span>
        <span class="n">flow</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">calcOpticalFlowFarneback</span><span class="p">(</span><span class="n">gray1</span><span class="p">,</span> <span class="n">gray2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span><span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>

        <span class="n">ssim</span><span class="o">=</span><span class="n">compare_images</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">)</span>
    

        <span class="n">flowx</span><span class="o">=</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">flowy</span><span class="o">=</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="n">flowx</span><span class="p">[</span><span class="n">ssim</span> <span class="o">&lt;</span><span class="n">ssim_thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flowy</span><span class="p">[</span><span class="n">ssim</span> <span class="o">&lt;</span><span class="n">ssim_thresh</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Compute the magnitude and angle of the 2D vectors</span>
        <span class="n">magnitude</span><span class="p">,</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">cartToPolar</span><span class="p">(</span><span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">)</span>
        <span class="c1">#magnitude = np.sqrt(flowx**2 + flowy**2)</span>
        
        

        <span class="c1"># Compute z-scores for the x_flow</span>
        <span class="n">z_scores_x</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Compute z-scores for the y_flow</span>
        <span class="n">z_scores_y</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        
        <span class="c1"># Create a mask for vectors with a z-score less than the threshold</span>
        <span class="n">mask_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_scores_y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zscore_threshold</span>
        <span class="n">mask_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">z_scores_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zscore_threshold</span>
        
        <span class="c1"># Zero out the vectors where the mask is False</span>
        <span class="n">flowx</span><span class="p">[</span><span class="o">~</span><span class="n">mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flowy</span><span class="p">[</span><span class="o">~</span><span class="n">mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">flowx</span><span class="p">[</span><span class="o">~</span><span class="n">mask_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">flowy</span><span class="p">[</span><span class="o">~</span><span class="n">mask_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        
        
        <span class="n">magnitude</span><span class="p">[</span><span class="o">~</span><span class="n">mask_x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">magnitude</span><span class="p">[</span><span class="o">~</span><span class="n">mask_y</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># Post-process magnitude to make it negative when flowx is negative</span>
        <span class="c1">#magnitude = np.where(flowx &lt; 0, -magnitude, magnitude)</span>
       
        <span class="k">return</span> <span class="n">magnitude</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">ssim</span>

    <span class="k">def</span> <span class="nf">filter_velocity</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">good_matches</span><span class="p">,</span> <span class="n">keypoints1</span><span class="p">,</span> <span class="n">keypoints2</span><span class="p">):</span>
        <span class="n">points1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">keypoints1</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">queryIdx</span><span class="p">]</span><span class="o">.</span><span class="n">pt</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">good_matches</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">points2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">([</span><span class="n">keypoints2</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">trainIdx</span><span class="p">]</span><span class="o">.</span><span class="n">pt</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">good_matches</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">velocity</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">points1</span><span class="p">)):</span>
            <span class="n">velocity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flow</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">points1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">velocity</span><span class="p">),</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span>

    <span class="k">def</span> <span class="nf">calculate_velocity_displacement</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">time_interval</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">time_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Time interval must not be zero.&quot;</span><span class="p">)</span>
        
        
        <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
            <span class="n">nframes</span><span class="o">=</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
            <span class="n">nframes</span><span class="o">=</span><span class="mi">3</span>
        <span class="n">velocity</span><span class="o">=</span> <span class="n">velocity</span><span class="o">/</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="o">/</span><span class="n">time_interval</span>
        
        <span class="n">flowx</span> <span class="o">=</span> <span class="n">flowx</span><span class="o">/</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="o">/</span><span class="n">time_interval</span>
        
        <span class="n">flowy</span> <span class="o">=</span> <span class="n">flowy</span><span class="o">/</span><span class="n">nframes</span> <span class="o">*</span> <span class="n">conversion_factor</span><span class="o">/</span><span class="n">time_interval</span>
        
        
        

        <span class="k">return</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span>


    <span class="kn">import</span> <span class="nn">re</span>

    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

    <span class="k">def</span> <span class="nf">separate_floats_letters</span><span class="p">(</span><span class="n">input_string</span><span class="p">):</span>
        <span class="n">floats</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\d+\.\d+|\d+&#39;</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
        <span class="n">letters</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;[a-zA-Z]+&#39;</span><span class="p">,</span> <span class="n">input_string</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">letters</span><span class="p">,</span> <span class="n">floats</span>

    <span class="n">input_string</span> <span class="o">=</span> <span class="n">image_resolution</span>
    <span class="n">unit</span><span class="p">,</span> <span class="n">img_res</span> <span class="o">=</span> <span class="n">separate_floats_letters</span><span class="p">(</span><span class="n">input_string</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">earthpy.plot</span> <span class="k">as</span> <span class="nn">ep</span>
    <span class="kn">import</span> <span class="nn">earthpy.spatial</span> <span class="k">as</span> <span class="nn">es</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="c1"># Import necessary packages</span>
    <span class="kn">import</span> <span class="nn">rasterio</span> <span class="k">as</span> <span class="nn">rio</span>
    <span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="kn">import</span> <span class="n">make_axes_locatable</span>

    <span class="k">def</span> <span class="nf">calculate_hillshade</span><span class="p">(</span><span class="n">dem_file_path</span><span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># Open the raster data</span>

        <span class="k">with</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dem_file_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">dem_src</span><span class="p">:</span>
            <span class="n">dem</span> <span class="o">=</span> <span class="n">dem_src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Calculate hillshade from the DEM</span>
        <span class="k">if</span> <span class="n">hillshade_option</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">hillshade</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">hillshade</span><span class="p">(</span><span class="n">dem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hillshade</span><span class="o">=</span><span class="n">dem</span>
        <span class="k">return</span> <span class="n">hillshade</span>

    
    
    <span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="k">as</span> <span class="nn">ET</span>
    
    
    <span class="k">def</span> <span class="nf">get_values_from_xml</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Parse the XML file</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">ET</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>

            <span class="c1"># Extracting x and y coordinates</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;ReferencePoint/Coordinates&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coordinates</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Parsing the coordinate string</span>
                <span class="n">coordinates_text</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">text</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="c1"># Assuming the format is &quot;(x, y)&quot;</span>
                <span class="n">coordinates_text</span> <span class="o">=</span> <span class="n">coordinates_text</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;() &quot;</span><span class="p">)</span>
                <span class="n">x_str</span><span class="p">,</span> <span class="n">y_str</span> <span class="o">=</span> <span class="n">coordinates_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x_str</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y_str</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># Extracting VEL and VEL_STD</span>
            <span class="n">veld_data</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VELDATA&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">veld_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vel</span> <span class="o">=</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">vel_std</span> <span class="o">=</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span> <span class="k">if</span> <span class="n">veld_data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;VEL_STD&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">vel</span><span class="p">,</span> <span class="n">vel_std</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>

            <span class="c1"># Convert to float if not None</span>
            <span class="n">x</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">vel</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span> <span class="k">if</span> <span class="n">vel</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">vel_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">vel_std</span><span class="p">)</span> <span class="k">if</span> <span class="n">vel_std</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">vel_std</span>

        <span class="k">except</span> <span class="n">ET</span><span class="o">.</span><span class="n">ParseError</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;XML Parse Error: </span><span class="si">{</span><span class="n">pe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
    
    
    <span class="k">def</span> <span class="nf">plot_reference_point</span><span class="p">(</span><span class="n">xml_file_path</span><span class="p">,</span> <span class="n">list_figures</span><span class="o">=</span><span class="p">[],</span> <span class="n">figure_paths</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts x, y coordinates from the given XML file and plots them on the provided axis.</span>

<span class="sd">        Args:</span>
<span class="sd">            - xml_file_path (str): Path to the XML file containing the reference point data.</span>
<span class="sd">            - ax (matplotlib.axes.Axes, optional): Axes on which to plot. If None, a new figure and axes will be created.</span>

<span class="sd">        Returns:</span>
<span class="sd">            - matplotlib.axes.Axes: The axes on which the data was plotted.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">xml_file_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">vel_std</span> <span class="o">=</span> <span class="n">get_values_from_xml</span><span class="p">(</span><span class="n">xml_file_path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">axs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_figures</span><span class="p">):</span>
                <span class="c1">#print(&quot;x, y&quot;, x, y)</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axs</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
                    <span class="c1"># We will annotate the point (x=5, y=sin(5))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;REF&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="c1"># 4. Save each figure to a PNG file</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_figures</span><span class="p">):</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figure_paths</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;.png&quot;</span><span class="p">)</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ReferencePoint x or y not found in the provided XML file.&quot;</span><span class="p">)</span>

        
       


    

    <span class="k">def</span> <span class="nf">plot_velocity_displacement</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">velocity</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">points1</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">date1</span><span class="p">,</span> <span class="n">date2</span><span class="p">,</span> <span class="n">pdf_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                    <span class="n">time_interval</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show_figure</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;unit&#39;</span><span class="p">,</span>
                                     <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">dem_file</span><span class="o">=</span><span class="n">dem_path</span><span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="n">hillshade_option</span><span class="p">):</span>
        
        
        <span class="k">if</span> <span class="n">hillshade_option</span><span class="p">:</span>
            
            <span class="n">hillshade</span><span class="o">=</span><span class="n">calculate_hillshade</span><span class="p">(</span><span class="n">dem_file</span> <span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="n">hillshade_option</span><span class="p">)</span>
        
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># It&#39;s already grayscale</span>
                <span class="n">gray</span><span class="o">=</span><span class="n">image1</span>
                
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># It&#39;s RGB</span>
                <span class="c1"># Convert RGB to grayscale using the weighted method</span>
                <span class="n">gray</span> <span class="o">=</span> <span class="mf">0.299</span> <span class="o">*</span> <span class="n">image1</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">image1</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.114</span> <span class="o">*</span> <span class="n">image1</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span>
                <span class="n">gray</span><span class="o">=</span><span class="n">gray</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
            <span class="n">hillshade</span><span class="o">=</span><span class="n">calculate_hillshade</span><span class="p">(</span><span class="n">gray</span> <span class="p">,</span> <span class="n">hillshade_option</span><span class="o">=</span><span class="n">hillshade_option</span><span class="p">)</span>
                
           
            

        <span class="c1">#image1=image1.transpose([1, 2, 0])  </span>
        <span class="c1"># image size in pixels</span>
        <span class="n">image_width</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">image_height</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># image bounds in geographic coordinates</span>
        <span class="n">geo_bounds</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="s1">&#39;bottom&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="s1">&#39;top&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">}</span>


        <span class="n">pixels</span> <span class="o">=</span> <span class="n">points1</span>
        
            
        <span class="c1"># convert pixel coordinates to geographic coordinates</span>
        <span class="n">geo_coords</span> <span class="o">=</span> <span class="p">[(</span><span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">image_width</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;right&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">]),</span>
                    <span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">image_height</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;top&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">geo_bounds</span><span class="p">[</span><span class="s1">&#39;bottom&#39;</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pixels</span><span class="p">]</span>

        <span class="c1"># separate the coordinates for plotting</span>
        <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">geo_coords</span><span class="p">)</span>

      
        <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span> <span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">mcolors</span>
            <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
            
            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vmin</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vmax</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Data has negative values, use TwoSlopeNorm</span>
                <span class="n">norm</span><span class="o">=</span><span class="n">mcolors</span><span class="o">.</span><span class="n">TwoSlopeNorm</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vcenter</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;rainbow&#39;</span>
                <span class="k">return</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Data has no negative values, use standard normalization</span>
                <span class="n">norm</span><span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">cmap</span> <span class="o">=</span> <span class="s1">&#39;viridis&#39;</span>
                
                <span class="k">return</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span>

        
        <span class="kn">import</span> <span class="nn">cmocean</span>

        
        <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Plot flowx</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[0, 0], title=f&#39;Disp-X({unit}) - {date1} to {date2}&#39;, extent=bounds)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowx</span><span class="p">))</span>
        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">flowx</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">minmax</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">minmax</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>

        <span class="n">flowx_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">flowx</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
       
        <span class="c1"># Create colorbar for flowx</span>
        <span class="n">flowx_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">flowx_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">flowx_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Disp-X(</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s1">) - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Plot flowy</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[0, 1], extent=bounds, title=f&#39;Disp-Y({unit}) - {date1} to {date2}&#39;)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">flowy</span><span class="p">))</span>
        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">flowy</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=-</span><span class="n">minmax</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">minmax</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>
        <span class="n">flowy_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">flowy</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Disp-Y(</span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s1">) - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Create colorbar for flowy</span>
        <span class="n">flowy_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">flowy_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">flowy_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">unit</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Plot Velocity Magnitude</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[1, 0], extent=bounds, title=f&#39;Velocity - {date1} to {date2}&#39;)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">minmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">velocity</span><span class="p">))</span>
        <span class="n">min_v</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">velocity</span><span class="p">)</span>

        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">velocity</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;rainbow&#39;</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">min_v</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">minmax</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>
        <span class="n">velocity_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">velocity</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>  <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Velocity - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1"># Create colorbar for velocity</span>
        <span class="n">velocity_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">velocity_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">velocity_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="p">(</span><span class="n">unit</span><span class="p">)</span><span class="si">}</span><span class="s1">/</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">time_interval</span><span class="p">)</span><span class="si">}</span><span class="s1">days&#39;</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="c1"># Plot Velocity Direction</span>
        <span class="c1">#ep.plot_rgb(image1, ax=axes[1, 1], extent=bounds, title=f&#39;Velocity Direction - {date1} to {date2}&#39;)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">hillshade</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">bounds</span><span class="p">)</span>
        <span class="n">velocity_direction</span> <span class="o">=</span> <span class="p">(</span><span class="mi">360</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">flowy</span><span class="p">,</span> <span class="n">flowx</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="mi">90</span><span class="p">)</span> <span class="o">%</span> <span class="mi">360</span>
        
        <span class="n">d</span><span class="o">=</span><span class="n">normalize</span><span class="p">(</span><span class="n">velocity_direction</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmocean</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">phase</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">360</span><span class="p">)</span>
        <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">d</span>
        <span class="n">velocity_direction_scatter</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">lons</span><span class="p">,</span> <span class="n">lats</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">velocity_direction</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="n">s</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Velocity Direction - </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s1"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># Create colorbar for velocity direction</span>
        <span class="n">velocity_direction_colorbar_axes</span> <span class="o">=</span> <span class="n">make_axes_locatable</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">append_axes</span><span class="p">(</span><span class="s2">&quot;right&quot;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="s2">&quot;5%&quot;</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">velocity_direction_scatter</span><span class="p">,</span> <span class="n">cax</span><span class="o">=</span><span class="n">velocity_direction_colorbar_axes</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s2">&quot;vertical&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;degrees&#39;</span><span class="p">)</span>
        

        <span class="c1"># Set the extent of the axes</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
        
        
        <span class="c1"># Automatically adjust subplot parameters for a tight layout</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">pdf_filename</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">pdf_filename</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">show_figure</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


    
        <span class="n">flowx_scatter</span><span class="o">=</span><span class="n">flowx_scatter</span><span class="o">.</span><span class="n">get_offsets</span><span class="p">()</span>
        <span class="n">x_data</span> <span class="o">=</span> <span class="n">flowx_scatter</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">y_data</span> <span class="o">=</span> <span class="n">flowx_scatter</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        

        <span class="k">return</span>  <span class="n">lons</span><span class="p">,</span> <span class="n">lats</span> <span class="p">,</span> <span class="n">pixels</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">fig</span><span class="p">,</span><span class="n">axes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">extract_date_from_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Searching for a date in the format &#39;YYYY-MM-DD&#39; or &#39;YYYYMMDD&#39;</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(\d</span><span class="si">{4}</span><span class="s1">-\d</span><span class="si">{2}</span><span class="s1">-\d</span><span class="si">{2}</span><span class="s1">)|(\d</span><span class="si">{8}</span><span class="s1">)&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">date_str</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
                <span class="c1"># Determine the date format</span>
                <span class="n">date_format</span> <span class="o">=</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="k">if</span> <span class="s1">&#39;-&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">date_str</span> <span class="k">else</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span>
                <span class="c1"># Parse the date string</span>
                <span class="n">date_obj</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date_str</span><span class="p">,</span> <span class="n">date_format</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">date_obj</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No date string found in filename.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Date string &#39;</span><span class="si">{</span><span class="n">date_str</span><span class="si">}</span><span class="s2">&#39; in filename is not in expected format.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>



    <span class="k">def</span> <span class="nf">mean_of_arrays</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">):</span>
        <span class="c1"># Determine the size of the larger array</span>
        <span class="n">max_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">array1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">array2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="c1"># Use np.pad to extend the smaller array with zeros</span>
        <span class="n">array1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array1</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">array1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">array2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array2</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">array2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
       <span class="c1"># Compute the mean of the two arrays element-wise</span>
        <span class="n">mean_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">([</span><span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        

        <span class="k">return</span> <span class="n">mean_array</span>

    

    <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">rasterio</span>
    <span class="kn">from</span> <span class="nn">rasterio.features</span> <span class="kn">import</span> <span class="n">geometry_mask</span>
    <span class="kn">from</span> <span class="nn">rasterio.transform</span> <span class="kn">import</span> <span class="n">from_origin</span>
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">griddata</span>
    <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">cKDTree</span>

    <span class="k">def</span> <span class="nf">replace_nan_with_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Create a 2D grid of coordinates based on the x, y values</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

            <span class="c1"># Flatten the coordinates grid and build a KDTree</span>
            <span class="n">flattened_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">xi</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yi</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">flattened_coordinates</span><span class="p">)</span>

            <span class="c1"># Query the tree for nearest neighbors to each point in x, y</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>

            <span class="c1"># Replace NaNs with z values at these indices</span>
            <span class="c1">#zi = np.full_like(xi, np.nan)</span>
            
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
        
            <span class="k">return</span> <span class="n">zi</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred:&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="k">return</span> <span class="n">zi</span>


    

    

    <span class="k">def</span> <span class="nf">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">reference_raster</span><span class="p">,</span> <span class="n">shapefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
    <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="o">=</span><span class="n">Vegetation_mask</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Get the CRS, width, height, and transform from the reference raster</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">reference_raster</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
                <span class="n">height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>
                <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
                <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">left</span>
                <span class="n">x_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span>
                <span class="n">y_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span>
                <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                

            <span class="c1"># Create a 2D grid of coordinates based on the x, y values</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
            <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">height</span><span class="p">)</span>
            <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

            <span class="c1"># Create an array of the same size as the x, y grid filled with NaN</span>
            <span class="c1">#zi = np.full_like(xi, yi, np.nan)</span>
            <span class="c1">#zi = np.zeros_like(xi)</span>

            
                

            <span class="k">if</span> <span class="n">interpolate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Interpolate z values onto the new grid</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Replace interpolated values outside the range with mean of initial z values</span>
                <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&lt;</span> <span class="n">z_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
                <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&gt;</span> <span class="n">z_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

                <span class="c1"># Find the indices of interpolated points exceeding the data range</span>
                <span class="n">out_of_range_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">xi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">yi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

                <span class="c1"># Replace out-of-range interpolated points with the mean of valid data points</span>
                <span class="n">zi_valid</span> <span class="o">=</span> <span class="n">zi</span><span class="p">[</span><span class="o">~</span><span class="n">out_of_range_indices</span><span class="p">]</span>
                <span class="n">mean_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">zi_valid</span><span class="p">)</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_of_range_indices</span><span class="p">,</span> <span class="n">mean_valid</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">interpolate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zi</span><span class="o">=</span><span class="n">replace_nan_with_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
                <span class="c1"># # Flatten the coordinates grid and build a KDTree</span>
                <span class="c1"># flattened_coordinates = np.column_stack((xi.ravel(), yi.ravel()))</span>
                <span class="c1"># tree = cKDTree(flattened_coordinates)</span>

                <span class="c1"># # Query the tree for nearest neighbors to each point in x, y</span>
                <span class="c1"># _, indices = tree.query(np.column_stack((x, y)))</span>

                <span class="c1"># # Replace NaNs with z values at these indices</span>
                <span class="c1"># np.put(zi, indices, z)</span>
                

                
            
             <span class="c1"># Apply low-pass filter</span>
            <span class="k">if</span> <span class="n">smoothing_kernel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1">#zi_initial=zi</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothing_kernel_size</span> <span class="p">)</span>  <span class="c1"># Adjust sigma according to your desired smoothing strength</span>
                <span class="c1">#if interpolate is None:</span>
                    <span class="c1">#zi[zi_initial == 0] = np.nan</span>

            <span class="k">if</span> <span class="n">shapefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Load shapefile, convert it to the correct CRS and get its geometry</span>
                <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
                <span class="n">shapes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span>

                <span class="c1"># Generate a mask from the shapes</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">geometry_mask</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">out_shape</span><span class="o">=</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Apply the mask to the interpolated data</span>
                <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zi</span><span class="o">=</span><span class="n">mask_raster</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">Vegetation_mask</span> <span class="p">)</span>


            <span class="c1"># Define the profile</span>
            <span class="n">profile</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
                <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
                <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
                <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">zi</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">crs</span><span class="p">,</span>
                <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
                <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># specify the nodata value</span>
            <span class="p">}</span>

            <span class="c1"># Write to a new .tif file</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
                <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred while creating the GeoTIFF:&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">zi</span>
    
    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">rasterio</span>
    <span class="kn">from</span> <span class="nn">rasterio.windows</span> <span class="kn">import</span> <span class="n">from_bounds</span>
    <span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">box</span>
    <span class="kn">from</span> <span class="nn">rasterio.mask</span> <span class="kn">import</span> <span class="n">mask</span>
    <span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
    <span class="k">def</span> <span class="nf">crop_to_overlap</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span><span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">):</span>
        
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>

            <span class="c1"># User provided start and end date strings</span>
            <span class="n">start_date</span> <span class="o">=</span> <span class="n">start_date</span>
            <span class="n">end_date</span> <span class="o">=</span> <span class="n">end_date</span>

            <span class="c1"># Converting the strings to datetime objects</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">start_date</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">end_date</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="c1"># Generating the list of dates</span>
            <span class="n">date_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">current_date</span> <span class="o">=</span> <span class="n">start</span>
            <span class="k">while</span> <span class="n">current_date</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">:</span>
                <span class="n">date_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current_date</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span>
                <span class="n">current_date</span> <span class="o">+=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">days</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
              
        <span class="c1">##############</span>
        
        <span class="n">image_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">))</span>
        
        <span class="c1">##Filter images based on start and end date</span>
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">image_files</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">date_list</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_files</span>
        <span class="c1">#########################</span>
        
        <span class="n">valid_extensions</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;.png&#39;</span><span class="p">,</span> <span class="s1">&#39;.bmp&#39;</span><span class="p">,</span> <span class="s1">&#39;.tiff&#39;</span><span class="p">]</span>
        <span class="n">image_path_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">bound_list</span><span class="o">=</span><span class="p">[]</span>

        <span class="c1"># Calculate mutual overlap</span>
        <span class="n">overlap_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">image_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">valid_extensions</span><span class="p">:</span>
                <span class="n">image_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
                <span class="n">image_path_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="n">meta</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">meta</span>
                    <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
                    <span class="n">bound_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bounds</span><span class="p">)</span>
                    <span class="n">image_box</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="o">*</span><span class="n">bounds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">overlap_box</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">overlap_box</span> <span class="o">=</span> <span class="n">image_box</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">overlap_box</span> <span class="o">=</span> <span class="n">overlap_box</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">image_box</span><span class="p">)</span>

        <span class="c1"># Read images and crop to mutual overlap</span>
        <span class="n">cropped_images</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">keypoints</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">descriptors</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">image_path</span> <span class="ow">in</span> <span class="n">image_path_list</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">image_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                <span class="n">overlap_window</span> <span class="o">=</span> <span class="n">from_bounds</span><span class="p">(</span><span class="o">*</span><span class="n">overlap_box</span><span class="o">.</span><span class="n">bounds</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">transform</span><span class="p">)</span>
                <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">window</span><span class="o">=</span><span class="n">overlap_window</span><span class="p">)</span>
                <span class="n">maskNan</span><span class="o">=</span><span class="n">cropped_image</span><span class="p">[</span><span class="n">cropped_image</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">meta</span><span class="o">=</span><span class="n">src</span><span class="o">.</span><span class="n">meta</span>
                 <span class="c1"># Rasterio reads data as (bands, height, width)</span>
                <span class="c1">#OpenCV expects data as (height, width, channels)</span>
                <span class="c1">#So we need to transpose the data</span>
                <span class="n">cropped_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">cropped_image</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">cropped_images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cropped_image</span><span class="p">)</span>
                <span class="n">kp</span><span class="p">,</span> <span class="n">des</span> <span class="o">=</span> <span class="n">detect_keypoints</span><span class="p">(</span><span class="n">cropped_image</span><span class="p">)</span>
                <span class="n">keypoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kp</span><span class="p">)</span>
                <span class="n">descriptors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">des</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>     
            <span class="n">filtered_dates</span><span class="o">=</span><span class="n">date_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filtered_dates</span><span class="o">=</span><span class="n">image_files</span>
        <span class="c1">#print(&quot;Cropped {} images.&quot;.format(len(cropped_images)))</span>
        <span class="k">return</span> <span class="n">cropped_images</span><span class="p">,</span> <span class="n">bound_list</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">,</span> <span class="n">image_path_list</span><span class="p">,</span> <span class="n">filtered_dates</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">maskNan</span>


    <span class="c1">##########################################################temp</span>
   
    





<span class="c1">###################################</span>

    <span class="kn">import</span> <span class="nn">os</span>
    <span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
    <span class="kn">import</span> <span class="nn">rasterio</span>
    <span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
    <span class="kn">from</span> <span class="nn">akhdefo_functions</span> <span class="kn">import</span> <span class="n">Auto_Variogram</span>
    

    <span class="k">def</span> <span class="nf">feature_matching</span><span class="p">(</span><span class="n">folder_path</span><span class="o">=</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> 
    <span class="n">AOI</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">img_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="o">=</span><span class="n">Vegetation_mask</span><span class="p">,</span> 
    <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="n">VEL_Mode</span><span class="p">,</span> <span class="n">shapefile_output</span><span class="o">=</span><span class="n">shapefile_output</span><span class="p">,</span> 
    <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> 
    <span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">,</span>
    <span class="n">master_reference</span><span class="o">=</span><span class="n">master_reference</span><span class="p">,</span> <span class="n">selection_Mode</span><span class="o">=</span><span class="n">selection_Mode</span> <span class="p">,</span> <span class="n">start_date</span><span class="o">=</span><span class="n">start_date</span> <span class="p">,</span> <span class="n">end_date</span><span class="o">=</span><span class="n">end_date</span><span class="p">):</span>
        
        <span class="n">folder_path</span> <span class="o">=</span> <span class="n">folder_path</span>
        
        <span class="n">images</span><span class="p">,</span> <span class="n">bound_list</span><span class="p">,</span> <span class="n">keypoints</span><span class="p">,</span> <span class="n">descriptors</span><span class="p">,</span> <span class="n">image_path_list</span><span class="p">,</span> <span class="n">filtered_dates</span><span class="p">,</span> <span class="n">meta</span><span class="p">,</span> <span class="n">maskNan</span> <span class="o">=</span> <span class="n">crop_to_overlap</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span>
        <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">filename</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">))]</span>

        <span class="n">image_files</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">image_files</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end_date</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">image_files</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">image_files</span> <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">filtered_dates</span><span class="p">]</span>

        <span class="c1">#image_files = sorted(os.listdir(folder_path))</span>
        <span class="c1"># images = []</span>
        <span class="c1"># keypoints = []</span>
        <span class="c1"># descriptors = []</span>
        <span class="c1"># bound_list=[]</span>
        <span class="c1"># # List of valid extensions</span>
        <span class="c1"># valid_extensions = [&#39;.tif&#39;, &#39;.jpg&#39;, &#39;.png&#39;, &#39;.bmp&#39;]</span>
        <span class="c1"># image_path_list=[]</span>
        <span class="c1"># for file in image_files :</span>
        <span class="c1">#     if os.path.splitext(file)[1] in valid_extensions:</span>
        <span class="c1">#         image_path = os.path.join(folder_path,file)</span>
        <span class="c1">#         image_path_list.append(image_path)</span>
        <span class="c1">#         with rasterio.open(image_path) as src:</span>
        <span class="c1">#             image = np.dstack([src.read(i) for i in src.indexes])  # This line stacks the bands of the image</span>
        <span class="c1">#             bounds=src.bounds</span>
        <span class="c1">#             bound_list.append(bounds)</span>
        <span class="c1">#             #image=src.read(1)</span>
        <span class="c1">#         images.append(image)</span>
        <span class="c1">#         kp, des = detect_keypoints(image)</span>
        <span class="c1">#         keypoints.append(kp)</span>
        <span class="c1">#         descriptors.append(des)</span>


        
        <span class="c1">######################</span>
        <span class="n">mean_vel_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">mean_flowx_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">mean_flowy_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pointx_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">pointsy_list</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">dates_names_list</span><span class="o">=</span><span class="p">[]</span>

        <span class="n">lf</span><span class="o">=</span><span class="mi">0</span>

        <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">zoom</span>
            <span class="n">mask_file</span><span class="o">=</span><span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">Vegetation_mask</span><span class="p">)</span>
            <span class="n">mask_data</span><span class="o">=</span><span class="n">mask_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ensure mask_data is boolean (0 or 1)</span>
            
        <span class="n">dem_src</span><span class="o">=</span> <span class="n">rio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dem_path</span><span class="p">)</span>  
        <span class="n">dem_crs</span><span class="o">=</span><span class="n">dem_src</span><span class="o">.</span><span class="n">crs</span>

        <span class="n">geodfs_x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">geodfs_y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">geodfs_v</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_figs</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">figure_paths</span><span class="o">=</span><span class="p">[]</span>
        
        <span class="c1">############################</span>
        <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
            <span class="n">loop_flag</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
            <span class="n">loop_flag</span><span class="o">=</span><span class="mi">2</span>
        
        <span class="c1">############################</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">images</span><span class="p">)</span><span class="o">-</span><span class="n">loop_flag</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing&quot;</span><span class="p">):</span>
            <span class="n">bound</span><span class="o">=</span><span class="n">bound_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image1</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">image2</span> <span class="o">=</span> <span class="n">images</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">image3</span><span class="o">=</span><span class="n">images</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]</span>
            
           
                
            
            
            <span class="c1">############################</span>
            <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
                <span class="n">image3</span><span class="o">=</span><span class="n">image2</span>
            <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
                <span class="n">image3</span><span class="o">=</span><span class="n">image3</span>
            
            <span class="c1">############################</span>
            <span class="n">keypoints1</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">keypoints2</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">keypoints3</span> <span class="o">=</span> <span class="n">keypoints</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]</span>
            <span class="n">descriptors1</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">descriptors2</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">descriptors3</span> <span class="o">=</span> <span class="n">descriptors</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># If the shapes don&#39;t match and dem_array is provided, resize mask_array</span>
                <span class="k">if</span> <span class="n">image1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">y_scale</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">x_scale</span> <span class="o">=</span> <span class="n">image1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">mask_data</span> <span class="o">=</span> <span class="n">zoom</span><span class="p">(</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">(</span><span class="n">y_scale</span><span class="p">,</span> <span class="n">x_scale</span><span class="p">))</span>

                    <span class="c1"># Threshold mask_array</span>
                    <span class="n">mask_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask_data</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">mask_data</span> <span class="o">=</span> <span class="n">mask_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
                
                <span class="c1"># Apply the mask for each band using broadcasting</span>
                <span class="n">image1</span><span class="p">[</span><span class="o">~</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">image2</span><span class="p">[</span><span class="o">~</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">image3</span><span class="p">[</span><span class="o">~</span><span class="n">mask_data</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># plt.imshow(image1)</span>
                <span class="c1"># plt.show()</span>



            <span class="c1"># descriptors1 and descriptors2 are assumed to be numpy arrays</span>
            <span class="n">descriptors12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">descriptors13</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">descriptors1</span><span class="p">,</span> <span class="n">descriptors3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">keypoints12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">keypoints1</span><span class="p">,</span> <span class="n">keypoints2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">keypoints13</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">keypoints1</span><span class="p">,</span> <span class="n">keypoints3</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">good_matches12</span> <span class="o">=</span> <span class="n">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">)</span>
            <span class="n">good_matches13</span> <span class="o">=</span> <span class="n">match_features</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">descriptors12</span><span class="p">,</span> <span class="n">descriptors13</span><span class="p">,</span> <span class="n">good_match_option</span><span class="o">=</span><span class="n">good_match_option</span><span class="p">)</span>

            <span class="n">flow12</span><span class="p">,</span> <span class="n">flowx12</span><span class="p">,</span> <span class="n">flowy12</span> <span class="p">,</span> <span class="n">ssim1</span><span class="o">=</span> <span class="n">calculate_optical_flow</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image2</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span> <span class="p">,</span>
                                                              <span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>
            <span class="n">flow13</span><span class="p">,</span> <span class="n">flowx13</span><span class="p">,</span> <span class="n">flowy13</span> <span class="p">,</span> <span class="n">ssim2</span><span class="o">=</span> <span class="n">calculate_optical_flow</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">,</span>
                                                              <span class="n">pyr_scale</span><span class="o">=</span><span class="n">pyr_scale</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span><span class="p">,</span> <span class="n">winsize</span><span class="o">=</span><span class="n">winsize</span><span class="p">,</span><span class="n">iterations</span><span class="o">=</span> <span class="n">iterations</span><span class="p">,</span> <span class="n">poly_n</span><span class="o">=</span><span class="n">poly_n</span><span class="p">,</span><span class="n">poly_sigma</span><span class="o">=</span> <span class="n">poly_sigma</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span>

            <span class="n">flow</span><span class="o">=</span><span class="n">mean_of_arrays</span><span class="p">(</span><span class="n">flow12</span><span class="p">,</span> <span class="n">flow13</span><span class="p">)</span>
            <span class="n">flowx</span><span class="o">=</span><span class="n">mean_of_arrays</span><span class="p">(</span><span class="n">flowx12</span><span class="p">,</span> <span class="n">flowx13</span><span class="p">)</span>
            <span class="n">flowy</span><span class="o">=</span><span class="n">mean_of_arrays</span><span class="p">(</span><span class="n">flowy12</span><span class="p">,</span><span class="n">flowy13</span><span class="p">)</span>
            
            <span class="n">ssim</span><span class="o">=</span><span class="p">(</span><span class="n">ssim1</span><span class="o">+</span><span class="n">ssim2</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>

            <span class="n">vel</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span> <span class="o">=</span> <span class="n">filter_velocity</span><span class="p">(</span><span class="n">flow</span><span class="p">,</span> <span class="n">good_matches12</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">)</span>
            <span class="n">flowx</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span> <span class="o">=</span> <span class="n">filter_velocity</span><span class="p">(</span><span class="n">flowx</span><span class="p">,</span> <span class="n">good_matches12</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">)</span>
            <span class="n">flowy</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span> <span class="o">=</span> <span class="n">filter_velocity</span><span class="p">(</span><span class="n">flowy</span><span class="p">,</span> <span class="n">good_matches12</span><span class="p">,</span> <span class="n">keypoints12</span><span class="p">,</span> <span class="n">keypoints13</span><span class="p">)</span>
            
            <span class="c1"># vel13, points1, points3 = filter_velocity(flow13, good_matches13, keypoints12, keypoints13)</span>
            <span class="c1"># flowx13, points1, points3 = filter_velocity(flowx13, good_matches13, keypoints12, keypoints13)</span>
            <span class="c1"># flowy13, points1, points3 = filter_velocity(flowy13, good_matches13, keypoints12, keypoints13)</span>

            <span class="c1"># points12 = np.concatenate((points1_i[:,0], points2[:,1]), axis=0)</span>
            <span class="c1"># points13 = np.concatenate((points1[:,0], points3[:,1]), axis=0)</span>

            <span class="c1"># print(points12.shape)</span>
            <span class="c1"># print(points13.shape)</span>

            <span class="c1">#Extract All dates to List for Later use</span>
            <span class="c1"># if master_reference:</span>
            <span class="c1">#     date1 = (extract_date_from_filename(image_files[0])).replace(&quot;-&quot;, &quot;&quot;)</span>
            <span class="c1"># else:</span>
            <span class="c1">#     date1 = (extract_date_from_filename(image_files[lf])).replace(&quot;-&quot;, &quot;&quot;)</span>
            <span class="n">date1</span> <span class="o">=</span> <span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">lf</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">start_date_init</span><span class="o">=</span><span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">date2</span> <span class="o">=</span> <span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">lf</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="n">date3</span><span class="o">=</span> <span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="n">lf</span> <span class="o">+</span> <span class="n">loop_flag</span><span class="p">]))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            
             <span class="c1">############################</span>
            <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
                <span class="n">date3</span><span class="o">=</span><span class="n">date2</span>
            <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
                <span class="n">date3</span><span class="o">=</span><span class="n">date3</span>
            
            <span class="c1">############################</span>
            
            <span class="n">lf</span><span class="o">=</span><span class="n">lf</span><span class="o">+</span><span class="mi">1</span>

            <span class="n">time_interval_1_2</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date2</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date1</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">days</span>
            <span class="n">time_interval_1_3</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date3</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">date1</span><span class="p">,</span> <span class="s1">&#39;%Y%m</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">days</span>
            <span class="k">if</span> <span class="n">time_interval_1_2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping computation for </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s2"> as the time interval is zero.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip the rest of this loop iteration</span>
            
            <span class="k">if</span> <span class="n">time_interval_1_2</span> <span class="o">&gt;</span> <span class="n">max_triplet_interval</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping computation for </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date2</span><span class="si">}</span><span class="s2"> as the time interval is larger than </span><span class="si">{</span><span class="n">max_triplet_interval</span><span class="si">}</span><span class="s2"> days.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip the rest of this loop iteration</span>
            
            <span class="k">if</span> <span class="n">time_interval_1_3</span> <span class="o">&gt;</span> <span class="n">max_triplet_interval</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Skipping computation for </span><span class="si">{</span><span class="n">date1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">date3</span><span class="si">}</span><span class="s2"> as the time interval is larger than </span><span class="si">{</span><span class="n">max_triplet_interval</span><span class="si">}</span><span class="s2"> days.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>  <span class="c1"># Skip the rest of this loop iteration</span>
        
            
            <span class="n">conversion_factor</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">img_res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># 1 pixel = 0.1 centimeter, meter, or mm etc..</span>

            <span class="c1">############################</span>
            <span class="k">if</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;pair&#39;</span><span class="p">:</span>
                <span class="n">time_interval_1_3</span><span class="o">=</span><span class="n">time_interval_1_2</span>
            <span class="k">elif</span> <span class="n">selection_Mode</span><span class="o">==</span><span class="s1">&#39;triplet&#39;</span><span class="p">:</span>
                <span class="n">time_interval_1_3</span><span class="o">=</span><span class="n">time_interval_1_3</span>
            
            <span class="c1">############################</span>
        
            <span class="n">vel</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span> <span class="o">=</span> <span class="n">calculate_velocity_displacement</span><span class="p">(</span><span class="n">vel</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span> <span class="p">,</span> <span class="n">time_interval_1_3</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="p">)</span>
            

            <span class="n">mean_vel_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>
            <span class="n">mean_flowx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flowx</span><span class="p">)</span>
            <span class="n">mean_flowy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flowy</span><span class="p">)</span>
            <span class="n">pointx_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points1_i</span><span class="p">)</span>
            <span class="n">pointsy_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">points2</span><span class="p">)</span>

            <span class="n">X_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/flowx/&quot;</span>
            <span class="n">Y_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/flowy/&quot;</span>
            <span class="n">VEL_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/vel/&quot;</span>
            <span class="n">plot_folder</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/plots/&quot;</span>

            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">X_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">X_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">Y_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">Y_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">VEL_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">VEL_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            

            <span class="n">file_name_x</span><span class="o">=</span><span class="n">X_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">file_name_y</span><span class="o">=</span><span class="n">Y_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">file_name_vel</span><span class="o">=</span><span class="n">VEL_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">plot_name</span><span class="o">=</span><span class="n">plot_folder</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>

            <span class="n">dates_names_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">))</span>
            
           <span class="c1">#####export ssim raster for later use########</span>
                
            <span class="c1"># Step 1: Read metadata from the reference raster</span>
            <span class="c1"># with rasterio.open(dem_path) as ref_raster:</span>
            <span class="c1">#     ref_meta = ref_raster.meta</span>
            <span class="c1">#     ref_meta.update({</span>
            <span class="c1">#     &#39;height&#39;: image1.shape[0],</span>
            <span class="c1">#     &#39;width&#39;: image1.shape[1]</span>
            <span class="c1"># })</span>
              
            <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;float32&#39;</span> <span class="p">,</span> <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">})</span>
            <span class="n">ssim</span><span class="p">[</span><span class="n">ssim</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ssim</span><span class="p">[</span><span class="n">ssim</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ssim</span><span class="p">[</span><span class="n">maskNan</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">ssim_outdir</span><span class="o">=</span> <span class="n">output_dir</span> <span class="o">+</span><span class="s2">&quot;/ssim&quot;</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">ssim_outdir</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">ssim_outdir</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="n">ssim_outdir_fname</span><span class="o">=</span><span class="n">ssim_outdir</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;.tif&quot;</span>
            <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">ssim_outdir_fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">meta</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst_ssim</span><span class="p">:</span>
                    <span class="n">dst_ssim</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">ssim</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            
            
            <span class="c1">##########################################</span>
            
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">fig_and_axes</span><span class="o">=</span> <span class="n">plot_velocity_displacement</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image3</span><span class="p">,</span> <span class="n">vel</span><span class="p">,</span> <span class="n">flowx</span><span class="p">,</span> <span class="n">flowy</span><span class="p">,</span> <span class="n">points1_i</span><span class="p">,</span> <span class="n">points2</span><span class="p">,</span> <span class="n">date1</span><span class="p">,</span> <span class="n">date3</span><span class="p">,</span> <span class="n">pdf_filename</span><span class="o">=</span><span class="n">plot_name</span><span class="p">,</span> <span class="n">time_interval</span><span class="o">=</span><span class="n">time_interval_1_3</span> <span class="p">,</span> 
                                             <span class="n">show_figure</span><span class="o">=</span><span class="n">show_figure</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">point_size</span><span class="p">,</span>
                                               <span class="n">bounds</span><span class="o">=</span><span class="p">[</span><span class="n">bound</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">bound</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">bound</span><span class="o">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bound</span><span class="o">.</span><span class="n">top</span><span class="p">])</span>
            
            <span class="n">list_figs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fig_and_axes</span><span class="p">)</span>
            <span class="n">figure_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot_name</span><span class="p">)</span>
            <span class="c1">############### flowx To Point Shapefile ####################</span>
            
            <span class="n">dfx</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">dfx</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
            <span class="n">dfx</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">z_data</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">dfx</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">=</span><span class="n">flowx</span>
            <span class="c1"># Change the dtype of a specific column to float32</span>
            <span class="n">dfx</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfx</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">gdfx</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">dfx</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">dfx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dfx</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

            <span class="c1">#geodfs_x.append(gdfx)</span>

            <span class="c1">############### flowy To Point Shapefile ####################</span>
            <span class="n">dfy</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">dfy</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
            <span class="n">dfy</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">z_data</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">dfy</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">=</span><span class="n">flowy</span>
            <span class="c1"># Change the dtype of a specific column to float32</span>
            <span class="n">dfy</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfy</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">gdfy</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">dfy</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">dfy</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dfy</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            

            <span class="c1">############### 2D_Vel To Point Shapefile ####################</span>
            <span class="n">dfv</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
            <span class="n">dfv</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
            <span class="n">dfv</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">y</span>
            <span class="n">z_data</span><span class="o">=</span><span class="s2">&quot;D&quot;</span><span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="n">dfv</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">=</span> <span class="n">vel</span>
            <span class="c1"># Change the dtype of a specific column to float32</span>
            <span class="n">dfv</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span> <span class="o">=</span> <span class="n">dfv</span><span class="p">[</span><span class="n">z_data</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;float32&#39;</span><span class="p">)</span>
            <span class="n">gdfv</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">dfv</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="n">dfv</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">dfv</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
            
           
            <span class="c1">#############################</span>

            <span class="c1"># east_x, east_y, east_z, gdfx=interpolate_kriging_nans_geodataframe(data=gdfx, </span>
            <span class="c1">#  threshold=None, variogram_model=None, out_fileName=None, plot=False)</span>

            <span class="c1"># north_x, north_y, north_z, gdfy=interpolate_kriging_nans_geodataframe(data=gdfy, </span>
            <span class="c1">#  threshold=None, variogram_model=None, out_fileName=None, plot=False)</span>

            <span class="c1"># vel2D_x, vel2D_y, vel2D_z, gdfv=interpolate_kriging_nans_geodataframe(data=gdfv, </span>
            <span class="c1">#  threshold=None, variogram_model=None, out_fileName=None, plot=False)</span>
            
            
            
            <span class="n">east_z</span><span class="o">=</span><span class="n">flowx</span>
            <span class="n">north_z</span><span class="o">=</span><span class="n">flowy</span>
            <span class="n">vel2D_z</span><span class="o">=</span><span class="n">vel</span>
            
            

            <span class="n">geodfs_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdfx</span><span class="p">)</span>
            <span class="n">geodfs_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdfy</span><span class="p">)</span>
            <span class="n">geodfs_v</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gdfv</span><span class="p">)</span>

            <span class="n">gdfx</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">gdfy</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">gdfv</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            
            <span class="k">if</span> <span class="n">interpolate</span><span class="o">==</span><span class="s1">&#39;kriging&#39;</span><span class="p">:</span>
                

                <span class="n">plot_folder_x</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/kriging_plots_x/&#39;</span>
                <span class="n">plot_folder_Y</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/kriging_plots_y/&#39;</span>
                <span class="n">plot_folder_VEL</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s1">&#39;/kriging_plots_2dvel/&#39;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder_x</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder_x</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder_Y</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder_Y</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">plot_folder_VEL</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">plot_folder_VEL</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>
                
                <span class="n">fname_rasters</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">date1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
                
                
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Auto_Variogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gdfx</span><span class="p">,</span> <span class="n">column_attribute</span><span class="o">=</span><span class="n">z_data</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aoi_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> 
                                <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> <span class="n">out_fileName</span><span class="o">=</span><span class="n">fname_rasters</span><span class="p">,</span> 
                                <span class="n">plot_folder</span><span class="o">=</span><span class="n">plot_folder_x</span><span class="p">,</span>  <span class="n">smoothing_kernel</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">geo_folder</span><span class="o">=</span><span class="n">X_folder</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto_Variogram failed with error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">east_z</span><span class="p">,</span> <span class="n">file_name_x</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Auto_Variogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gdfy</span><span class="p">,</span> <span class="n">column_attribute</span><span class="o">=</span><span class="n">z_data</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aoi_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span>
                                <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> <span class="n">out_fileName</span><span class="o">=</span><span class="n">fname_rasters</span><span class="p">,</span> 
                                <span class="n">plot_folder</span><span class="o">=</span><span class="n">plot_folder_Y</span><span class="p">,</span> <span class="n">smoothing_kernel</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">geo_folder</span><span class="o">=</span><span class="n">Y_folder</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto_Variogram failed with error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">north_z</span><span class="p">,</span> <span class="n">file_name_y</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span> <span class="p">)</span>
                
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">Auto_Variogram</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">gdfv</span><span class="p">,</span> <span class="n">column_attribute</span><span class="o">=</span><span class="n">z_data</span><span class="p">,</span> <span class="n">latlon</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">aoi_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> 
                                <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="p">,</span><span class="n">num_chunks</span><span class="o">=</span><span class="n">num_chunks</span><span class="p">,</span><span class="n">overlap_percentage</span><span class="o">=</span><span class="n">overlap_percentage</span><span class="p">,</span> <span class="n">out_fileName</span><span class="o">=</span><span class="n">fname_rasters</span><span class="p">,</span> 
                                <span class="n">plot_folder</span><span class="o">=</span><span class="n">plot_folder_VEL</span><span class="p">,</span> <span class="n">smoothing_kernel</span><span class="o">=</span><span class="n">smoothing_kernel_size</span><span class="p">,</span> <span class="n">geo_folder</span><span class="o">=</span><span class="n">VEL_folder</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Auto_Variogram failed with error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vel2D_z</span><span class="p">,</span> <span class="n">file_name_vel</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span> <span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                   
                <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">east_z</span><span class="p">,</span> <span class="n">file_name_x</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span> <span class="p">)</span>
                <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">north_z</span><span class="p">,</span> <span class="n">file_name_y</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span> <span class="p">)</span>
                <span class="n">save_xyz_as_geotiff</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">vel2D_z</span><span class="p">,</span> <span class="n">file_name_vel</span><span class="p">,</span> <span class="n">dem_path</span><span class="p">,</span> <span class="n">AOI</span> <span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="n">interpolate</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">Vegetation_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">X_folder</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="p">)</span>
            <span class="n">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">Y_folder</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="p">)</span>
            <span class="n">mask_all_rasters_in_directory</span><span class="p">(</span><span class="n">VEL_folder</span><span class="p">,</span> <span class="n">Vegetation_mask</span><span class="p">)</span>
            
            
        <span class="n">dates_list</span><span class="o">=</span><span class="p">[</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">image_files</span><span class="p">]</span>
        <span class="c1"># Filter image_files based on extensions and extract dates</span>
        <span class="c1"># image_extensions = [&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;, &#39;.tif&#39;, &#39;.tiff&#39;]</span>
        <span class="c1"># dates_list = [extract_date_from_filename(filename) for filename in image_files if os.path.splitext(filename)[1].lower() in image_extensions]</span>
            
        <span class="n">Total_days</span> <span class="o">=</span> <span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">image_files</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">extract_date_from_filename</span><span class="p">(</span><span class="n">image_files</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1">&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">days</span>
        
        
        <span class="c1"># # Concatenate GeoDataFrames</span>
        <span class="c1"># geodfs_x = pd.concat(geodfs_x, axis=0).reset_index(drop=True)</span>
        <span class="c1"># geodfs_y = pd.concat(geodfs_y, axis=0).reset_index(drop=True)</span>
        <span class="c1"># geodfs_v = pd.concat(geodfs_v, axis=0).reset_index(drop=True)</span>
        

        
 
        <span class="k">if</span> <span class="n">shapefile_output</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            
            <span class="n">shapefile_temp_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/&quot;</span><span class="o">+</span><span class="s2">&quot;temp_shapefile_dir&quot;</span>
            
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            
            <span class="n">shapefileName</span><span class="o">=</span><span class="n">shapefile_temp_dir</span> <span class="o">+</span><span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">start_date_init</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date2</span><span class="p">)</span><span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">date3</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Wait for processing to complete writing data into shapefile for timeseries...&#39;</span><span class="p">)</span>
            
           
            <span class="n">geodfs_x</span><span class="o">=</span><span class="n">merge_geodataframes</span><span class="p">(</span><span class="n">geodfs_x</span><span class="p">)</span>
            <span class="n">geodfs_x</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">geodfs_x</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_E.shp&#39;</span><span class="p">)</span>
            
            <span class="k">del</span> <span class="n">geodfs_x</span>
            
            <span class="n">geodfs_y</span><span class="o">=</span><span class="n">merge_geodataframes</span><span class="p">(</span><span class="n">geodfs_y</span><span class="p">)</span>
            <span class="c1">#######################3######</span>
        
            <span class="n">geodfs_y</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">geodfs_y</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_N.shp&#39;</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">geodfs_y</span>
            <span class="c1">###########################</span>
           
            <span class="n">geodfs_v</span><span class="o">=</span><span class="n">merge_geodataframes</span><span class="p">(</span><span class="n">geodfs_v</span><span class="p">)</span>
            <span class="c1">#print(&quot;DataFrame 2DVEL Summary:\n&quot;, geodfs_v.describe())</span>
            <span class="n">geodfs_v</span><span class="o">.</span><span class="n">crs</span><span class="o">=</span><span class="n">dem_crs</span>
            <span class="n">geodfs_v</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">shapefileName</span> <span class="o">+</span> <span class="s1">&#39;_2DVEL.shp&#39;</span><span class="p">)</span>
            
            <span class="k">del</span> <span class="n">geodfs_v</span>
           
            <span class="kn">import</span> <span class="nn">akhdefo_functions</span>
            <span class="kn">from</span> <span class="nn">akhdefo_functions</span> <span class="kn">import</span> <span class="n">Crop_to_AOI</span>
            <span class="c1"># ####3Look for stable pixel###########</span>
            <span class="c1"># os.makedirs(ssim_outdir + &#39;/cropped&#39;, exist_ok=True)</span>

            <span class="c1"># Crop_to_AOI(Path_to_WorkingDir=ssim_outdir, </span>
            <span class="c1">#                   Path_to_AOI_shapefile=AOI, </span>
            <span class="c1">#                   output_CroppedDir=ssim_outdir+ &#39;/cropped&#39;, file_ex=&#39;.tif&#39;)</span>
            <span class="c1"># gdf_ssim=process_shapefile_with_rasters(shapefileName +&#39;_E.shp&#39;, ssim_outdir + &#39;/cropped&#39;)</span>
            <span class="c1"># #print(gdf_ssim.ssim_V.iloc[reference_index])</span>
            <span class="c1"># gdf_ssim.crs=dem_crs</span>
            <span class="c1"># gdf_ssim.to_file(output_dir+&quot;/ssim_E.shp&quot;)</span>
            
            <span class="c1"># ###########3</span>
            <span class="c1"># gdf_ssim=process_shapefile_with_rasters(shapefileName +&#39;_N.shp&#39;, ssim_outdir + &#39;/cropped&#39;)</span>
            <span class="c1"># #print(gdf_ssim.ssim_V.iloc[reference_index])</span>
            <span class="c1"># gdf_ssim.crs=dem_crs</span>
            <span class="c1"># gdf_ssim.to_file(output_dir+&quot;/ssim_N.shp&quot;)</span>
            
        
            <span class="c1"># ########</span>
            
            <span class="c1"># gdf_ssim=process_shapefile_with_rasters(shapefileName +&#39;_E.shp&#39;, ssim_outdir + &#39;/cropped&#39;)</span>
            <span class="c1"># #print(gdf_ssim.ssim_V.iloc[reference_index])</span>
            <span class="c1"># gdf_ssim.crs=dem_crs</span>
            <span class="c1"># gdf_ssim.to_file(output_dir+&quot;/ssim_2DVEL.shp&quot;)</span>
            <span class="c1">#################</span>
            

           
            <span class="n">raster_folder</span><span class="o">=</span><span class="p">[</span><span class="n">VEL_folder</span><span class="p">,</span> <span class="n">Y_folder</span><span class="p">,</span> <span class="n">X_folder</span><span class="p">]</span>
            <span class="c1">#SSIM_shape_list=[shapefileName +&#39;_E.shp&#39;, shapefileName +&#39;_N.shp&#39;, shapefileName +&#39;_2DVEL.shp&#39;]</span>
            
            <span class="c1">####Loop to update raster to crop to AOI#####3</span>
            <span class="kn">import</span> <span class="nn">shutil</span> 
            <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">raster_folder</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing:Updating and Cropping Rasters&quot;</span><span class="p">)):</span>
                <span class="n">cropped_dir</span><span class="o">=</span><span class="n">raster_folder</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/cropped&#39;</span>
               
                <span class="c1"># Check if the subdirectory exists</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">):</span>
                    <span class="c1"># Remove the existing subdirectory</span>
                    <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">)</span>

                <span class="c1"># # Create the subdirectory again</span>
                <span class="c1"># os.makedirs(sub_dir_path, exist_ok=True)</span>
                
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">Crop_to_AOI</span><span class="p">(</span><span class="n">Path_to_WorkingDir</span><span class="o">=</span><span class="n">raster_folder</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">Path_to_AOI_shapefile</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> <span class="n">output_CroppedDir</span><span class="o">=</span><span class="n">cropped_dir</span><span class="p">,</span> <span class="n">file_ex</span><span class="o">=</span><span class="s1">&#39;.tif&#39;</span><span class="p">)</span>
            
            <span class="kn">import</span> <span class="nn">time</span>
            <span class="c1"># Wait for 10 seconds</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
            
            
            <span class="n">data_list</span><span class="o">=</span><span class="p">[</span><span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_2DVEL.shp&#39;</span><span class="p">,</span> <span class="n">shapefileName</span> <span class="o">+</span><span class="s1">&#39;_N.shp&#39;</span><span class="p">,</span> <span class="n">shapefileName</span> <span class="o">+</span> <span class="s1">&#39;_E.shp&#39;</span> <span class="p">]</span>
            <span class="c1">######################################</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Processing: Update Shapefiles &quot;</span> <span class="p">)):</span>
                <span class="n">cropped_dir</span><span class="o">=</span><span class="n">raster_folder</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;/cropped&#39;</span>
               
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;processing </span><span class="si">{</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> started... &#39;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cropped_dir</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                
                <span class="n">updated_geodf</span><span class="p">,</span> <span class="n">update_shapefile_dir</span><span class="o">=</span><span class="n">update_nodata_values</span><span class="p">(</span><span class="n">shapefile_path</span><span class="o">=</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rasterfile_paths</span><span class="o">=</span><span class="n">cropped_dir</span><span class="p">,</span><span class="n">interpolate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">VEL_Mode</span><span class="o">=</span><span class="n">VEL_Mode</span> <span class="p">,</span> <span class="n">VEL_scale</span><span class="o">=</span><span class="n">VEL_scale</span> <span class="p">,</span>
                                     <span class="n">master_reference</span><span class="o">=</span><span class="n">master_reference</span><span class="p">,</span> <span class="n">Total_days</span><span class="o">=</span><span class="n">Total_days</span><span class="p">)</span>
                
                
                <span class="c1"># update_nodata_values(shapefile_path=data_list[i], rasterfile_paths=cropped_dir,interpolate=False, VEL_Mode=VEL_Mode , VEL_scale=VEL_scale ,</span>
                <span class="c1">#                      master_reference=master_reference, Total_days=Total_days, reference_index=best_match_index)</span>
                
                <span class="c1">#update_nodata_values(shapefile_path=data_list[k], rasterfile_paths=raster_folder[k],interpolate=False, VEL_Mode=VEL_Mode , VEL_scale=VEL_scale , master_reference=master_reference, Total_days=Total_days)</span>
                <span class="c1">#update_nodata_values(shapefile_path=data_list[k], rasterfile_paths=raster_folder[k],interpolate=False, VEL_Mode=VEL_Mode , VEL_scale=VEL_scale , master_reference=master_reference, Total_days=Total_days)</span>

                <span class="c1"># interpolate_kriging_nans_geodataframe(data=data_list[k], </span>
                <span class="c1">#     threshold=None, variogram_model=None, out_fileName=None, plot=False, </span>
                <span class="c1">#     Total_days=Total_days,VEL_scale=VEL_scale, VEL_Mode=VEL_Mode)</span>

                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;processing </span><span class="si">{</span><span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1"> completed... &#39;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            
           
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Total Days: </span><span class="si">{</span><span class="n">Total_days</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_dir</span><span class="o">+</span><span class="s2">&quot;/Names.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">dates_names_list</span><span class="p">:</span>
                <span class="c1"># write each item on a new line</span>
                <span class="n">file</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">item</span><span class="p">)</span>

        
        <span class="k">def</span> <span class="nf">find_file</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">suffix</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="n">xml_file_path</span><span class="o">=</span><span class="n">find_file</span><span class="p">(</span><span class="n">shapefile_temp_dir</span><span class="p">,</span> <span class="s2">&quot;_2DVEL.shp.xml&quot;</span><span class="p">)</span>
        
       
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;file used&quot;</span><span class="p">,</span> <span class="n">xml_file_path</span><span class="p">)</span>
       <span class="c1"># Check if the file exists</span>
        <span class="k">if</span> <span class="n">xml_file_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plot_reference_point</span><span class="p">(</span><span class="n">xml_file_path</span><span class="p">,</span> <span class="n">list_figs</span><span class="p">,</span> <span class="n">figure_paths</span><span class="p">)</span>
            
        <span class="c1">#print(f&#39;Dates: {dates_list}&#39;)</span>

    <span class="c1">#     data=[dates_list,pointx_list, pointsy_list, mean_flowx_list, mean_flowy_list,mean_vel_list ]</span>
    <span class="c1">#    # Create DataFrame</span>
    <span class="c1">#     df = pd.DataFrame(data, columns=column_names)</span>

        <span class="c1"># Free up memory by manually invoking garbage collection</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="c1">#image1, image3, mean_vel_list, mean_flowx_list, mean_flowy_list, points1_i, points2, dates_list[0], dates_list[len(dates_list)-1]</span>
        
        <span class="c1">#return </span>

    <span class="n">feature_matching</span><span class="p">(</span><span class="n">folder_path</span><span class="o">=</span><span class="n">input_dir</span><span class="p">,</span> <span class="n">output_dir</span><span class="o">=</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">zscore_threshold</span><span class="o">=</span><span class="n">zscore_threshold</span><span class="p">,</span> <span class="n">AOI</span><span class="o">=</span><span class="n">AOI</span><span class="p">,</span> <span class="n">conversion_factor</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">img_res</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ssim_thresh</span><span class="o">=</span><span class="n">ssim_thresh</span><span class="p">)</span></div>

   

    
<span class="c1">#######################################</span>



<div class="viewcode-block" id="interpolate_xyz"><a class="viewcode-back" href="../../akhdefo_functions.html#akhdefo_functions.Akhdefo_GOI.interpolate_xyz">[docs]</a><span class="k">def</span> <span class="nf">interpolate_xyz</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">reference_raster</span><span class="p">,</span> <span class="n">shapefile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                        <span class="n">smoothing_kernel_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save XYZ data as a GeoTIFF file using a reference raster for geospatial context.</span>

<span class="sd">    This function takes X, Y, Z coordinate data and generates a GeoTIFF file. The geospatial context</span>
<span class="sd">    is derived from a reference raster file. The function supports optional interpolation of Z values,</span>
<span class="sd">    spatial smoothing, and masking based on a shapefile or a predefined  mask.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        x (array_like): Array of X coordinates.</span>
<span class="sd">        y (array_like): Array of Y coordinates.</span>
<span class="sd">        z (array_like): Array of Z values corresponding to X and Y coordinates.</span>
<span class="sd">        filename (str): The base name of the output GeoTIFF file (without file extension).</span>
<span class="sd">        reference_raster (str): Path to the reference raster file used for spatial context (CRS, bounds, etc.).</span>
<span class="sd">        shapefile (str, optional): Path to a shapefile for masking the output raster. Defaults to None.</span>
<span class="sd">        interpolate (str, optional): Interpolation method to be used (e.g., &#39;linear&#39;, &#39;nearest&#39;). If None, a nearest-neighbor approach is applied. Defaults to None.</span>
<span class="sd">        smoothing_kernel_size (int or float, optional): The size of the Gaussian kernel used for smoothing the Z values. Defaults to None.</span>
<span class="sd">        mask (array_like, optional): A boolean mask array to mask vegetation areas. Defaults to None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        numpy.ndarray: The array of interpolated/smoothed Z values, which is also saved as a GeoTIFF file.</span>

<span class="sd">    Raises:</span>
<span class="sd">        Exception: If an error occurs during the process.</span>

<span class="sd">        Notes:</span>
<span class="sd">        - The function uses `rasterio` for raster operations and `numpy` and `scipy` for data processing.</span>
<span class="sd">        - The output GeoTIFF file will have the same spatial extent, resolution, and coordinate reference system (CRS) as the reference raster.</span>
<span class="sd">        - If &#39;interpolate&#39; is not None, Z values are interpolated over the grid defined by the reference raster. Out-of-range interpolated values are replaced with the mean of valid data points.</span>
<span class="sd">        - If &#39;smoothing_kernel_size&#39; is provided, a Gaussian smoothing is applied to the Z values.</span>
<span class="sd">        - Masking with either a shapefile or a vegetation mask will set the corresponding areas to NaN.</span>
<span class="sd">        - The output file is named using the &#39;filename&#39; parameter with &#39;.tif&#39; extension.</span>

<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Get the CRS, width, height, and transform from the reference raster</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">reference_raster</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
            <span class="n">crs</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">crs</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">width</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">height</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">transform</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">left</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">right</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">bottom</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="n">bounds</span><span class="o">.</span><span class="n">top</span>
            <span class="n">pixel_size_x</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pixel_size_y</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">res</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            

        <span class="c1"># Create a 2D grid of coordinates based on the x, y values</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">width</span><span class="p">)</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">height</span><span class="p">)</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">)</span>

        <span class="c1"># Create an array of the same size as the x, y grid filled with NaN</span>
        <span class="c1">#zi = np.full_like(xi, yi, np.nan)</span>
        <span class="c1">#zi = np.zeros_like(xi)</span>

        
            

        <span class="k">if</span> <span class="n">interpolate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Interpolate z values onto the new grid</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">griddata</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">,</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">),</span> <span class="n">method</span><span class="o">=</span><span class="n">interpolate</span><span class="p">,</span> <span class="n">rescale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Replace interpolated values outside the range with mean of initial z values</span>
            <span class="n">z_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">z_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&lt;</span> <span class="n">z_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">zi</span><span class="p">[</span><span class="n">zi</span> <span class="o">&gt;</span> <span class="n">z_max</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

            <span class="c1"># Find the indices of interpolated points exceeding the data range</span>
            <span class="n">out_of_range_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">xi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">yi</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">yi</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

            <span class="c1"># Replace out-of-range interpolated points with the mean of valid data points</span>
            <span class="n">zi_valid</span> <span class="o">=</span> <span class="n">zi</span><span class="p">[</span><span class="o">~</span><span class="n">out_of_range_indices</span><span class="p">]</span>
            <span class="n">mean_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">zi_valid</span><span class="p">)</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_of_range_indices</span><span class="p">,</span> <span class="n">mean_valid</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zi</span><span class="o">=</span><span class="n">replace_nan_with_nearest</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
            <span class="c1"># # Flatten the coordinates grid and build a KDTree</span>
            <span class="c1"># flattened_coordinates = np.column_stack((xi.ravel(), yi.ravel()))</span>
            <span class="c1"># tree = cKDTree(flattened_coordinates)</span>

            <span class="c1"># # Query the tree for nearest neighbors to each point in x, y</span>
            <span class="c1"># _, indices = tree.query(np.column_stack((x, y)))</span>

            <span class="c1"># # Replace NaNs with z values at these indices</span>
            <span class="c1"># np.put(zi, indices, z)</span>
            

            
        
            <span class="c1"># Apply low-pass filter</span>
        <span class="k">if</span> <span class="n">smoothing_kernel_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#zi_initial=zi</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">smoothing_kernel_size</span> <span class="p">)</span>  <span class="c1"># Adjust sigma according to your desired smoothing strength</span>
            <span class="c1">#if interpolate is None:</span>
                <span class="c1">#zi[zi_initial == 0] = np.nan</span>

        <span class="k">if</span> <span class="n">shapefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Load shapefile, convert it to the correct CRS and get its geometry</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">shapefile</span><span class="p">)</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span>

            <span class="c1"># Generate a mask from the shapes</span>
            <span class="n">mask1</span> <span class="o">=</span> <span class="n">geometry_mask</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span> <span class="n">out_shape</span><span class="o">=</span><span class="n">zi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">all_touched</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Apply the mask to the interpolated data</span>
            <span class="n">zi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">zi</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zi</span><span class="o">=</span><span class="n">mask_raster</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="n">mask</span> <span class="p">)</span>


        <span class="c1"># Define the profile</span>
        <span class="n">profile</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;driver&#39;</span><span class="p">:</span> <span class="s1">&#39;GTiff&#39;</span><span class="p">,</span>
            <span class="s1">&#39;height&#39;</span><span class="p">:</span> <span class="n">height</span><span class="p">,</span>
            <span class="s1">&#39;width&#39;</span><span class="p">:</span> <span class="n">width</span><span class="p">,</span>
            <span class="s1">&#39;count&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">zi</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="s1">&#39;crs&#39;</span><span class="p">:</span> <span class="n">crs</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="n">transform</span><span class="p">,</span>
            <span class="s1">&#39;nodata&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>  <span class="c1"># specify the nodata value</span>
        <span class="p">}</span>

        <span class="c1"># Write to a new .tif file</span>
        <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span> <span class="o">+</span> <span class="s2">&quot;.tif&quot;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">profile</span><span class="p">)</span> <span class="k">as</span> <span class="n">dst</span><span class="p">:</span>
            <span class="n">dst</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">zi</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;An error occurred while creating the GeoTIFF:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">zi</span></div>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Mahmud Mustafa
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023, Mahmud Mustafa Muhammad.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>